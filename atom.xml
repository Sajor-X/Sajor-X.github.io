<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2022-01-29T21:50:36+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[滑动验证码识别]]></title>
    <link href="http://565785929.github.io/16434266223947.html"/>
    <updated>2022-01-29T11:23:42+08:00</updated>
    <id>http://565785929.github.io/16434266223947.html</id>
    <content type="html"><![CDATA[
<p>今天的目标地址是抖音的<a href="https://business.oceanengine.com/site/login">巨量纵横</a>，目前东家是一家广告营销型的公司，专注于在各大平台投放信息流广告。巨量纵横为今日头条的广告平台，用于管理推广账户。今天破解一下这个平台的登陆入口，为今后的数据爬取开个头。</p>

<h2 id="toc_0">涉及工具技术</h2>

<ul>
<li>selenium</li>
<li>pandas</li>
<li>numpy</li>
<li>opencv</li>
<li><a href="https://pillow.readthedocs.io/en/stable/">Pillow</a></li>
</ul>

<h2 id="toc_1">开始</h2>

<p><img src="media/16434266223947/16434586795750.jpg" alt="" style="width:377px;"/></p>

<p>滑动验证码就是上图这种东西，验证方式就是用鼠标拖动到缺口阴影位置松手即可。</p>

<p>逻辑比较简单，目前要处理的核心问题就是怎么找到这个阴影位置，因为可能有不同的图片而且图片中缺口阴影的位置也不确定。</p>

<p>问题可以简化为：<strong>如何找到背景图中缺口的准确位置</strong></p>

<h2 id="toc_2">分析</h2>

<p>首先通过浏览器检查工具，看一下能获得哪些信息。</p>

<p><img src="media/16434266223947/16434585467283.jpg" alt="" style="width:1131px;"/></p>

<p>首先可以获得<strong>滑块和缺口图片的链接</strong>，还可以获取<strong>滑块图片的高度</strong></p>

<p>我们先将缺口图片下载下来，通过简单的图像变换看一下有什么特征可以利用。下面Python代码可用于下载图片。</p>

<pre class="line-numbers"><code class="language-python">from urllib import request

img = &#39;https://p6-catpcha.byteimg.com/tos-cn-i-188rlo5p4y/7fcb5c88410943579af133942e8f9249~tplv-188rlo5p4y-2.jpeg&#39;

request.urlretrieve(img, &#39;./img.jpg&#39;)
</code></pre>

<p>将图片保存下来之后，使用较为通用的处理方法先观察一下图片特点，首先灰度处理，再手动调整阈值观察二值化后的图片。</p>

<p><img src="media/16434266223947/16434598980447.jpg" alt="" style="width:945px;"/></p>

<p>通过观察可以发现带缺口图片附近有一圈白色痕迹，我们就是要获取到白色方框的左半部分距离整个图片左边的距离。</p>

<p>通过观察二值化后的图片特征，我想到一个办法，就是通过这张二值化后的图片，遍历每一个像素点，找到连续的、在垂直方向均为白色的位置。理论上是可行的，可能验证码图片样本不够，可能会有些图片白色部分较多，比如这张银色的车，白色的色块就比较多。</p>

<p><img src="media/16434266223947/16434600496969.jpg" alt="" style="width:376px;"/></p>

<h2 id="toc_3">滤波</h2>

<p>因为我们只需要缺口的左边位置的坐标，所以可以通过具有提取边缘特征的水平梯度Prewitt卷积核来处理图片。通过测试我选取了下面这个3x3的卷积核。</p>

<p>\[<br/>
\begin{bmatrix}<br/>
1 &amp; 0 &amp; -2\\<br/>
1 &amp; 0 &amp; -2\\<br/>
1 &amp; 0 &amp; -2\\<br/>
\end{bmatrix}<br/>
\]</p>

<p>通过opencv库处理原图，可以发现图片缺口左边部分的边缘被突出显示了出来。<br/>
<img src="media/16434266223947/16434607760833.jpg" alt="" style="width:861px;"/></p>

<h2 id="toc_4">结果</h2>

<p>有了如上的矩阵就简单了，按照之前的思路，找到垂直方向的白线就可以拿到缺口的坐标。</p>

<p>遍历图片每一个点，将<strong>白色点的x坐标</strong>存入一维数组中，再求该数列的<strong>众数</strong>就能得出缺口的坐标啦！</p>

<p>偷个懒，众数的不优雅表达<br/>
<code>pd.Series(np.array(res_list)).mode()[0]</code></p>

<p><img src="media/16434266223947/16434629389321.jpg" alt="" style="width:986px;"/></p>

<h2 id="toc_5">切图</h2>

<p>为了更高的准确率，我们之前还能拿到滑块图片的高度，我们可以将验证码无用部分，也就是缺口部分上下方图片切除掉。</p>

<p>可以通过selenium库 <code>img.value_of_css_property(&quot;top&quot;)</code> 方法获取页面元素属性，拿到滑块图片的高度，通过后面测量，与原图大概是1.65倍(这个不知道是什么单位的倍数，下面会展示计算方法)，滑块高度大约110像素。numpy切片的代码就不放了。切出来的图片类似这样，再进行上面的操作，脑补是能减少误判(没测过😊)</p>

<p><img src="media/16434266223947/immg1.jpg" alt="immg1"/></p>

<p><img src="media/16434266223947/immg2.jpg" alt="immg2"/></p>

<h2 id="toc_6">控制浏览器</h2>

<p>核心难点突破之后就简单多了，使用selenium这个库来控制浏览器，使用代码的方式操纵鼠标键盘。</p>

<p>未完待续...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 字体安装]]></title>
    <link href="http://565785929.github.io/16425740174242.html"/>
    <updated>2022-01-19T14:33:37+08:00</updated>
    <id>http://565785929.github.io/16425740174242.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16425740174242/16434636451231.jpg" alt=""/></p>

<p>今天要实现一个freemarker模板转HTML再转成PDF 或者 图片的需求。</p>

<p>本地代码执行好使，上线到linux服务器上测试就出现汉字不显示的情况。</p>

<pre class="line-numbers"><code class="language-bash"># 安装字体命令
yum -y install fontconfig

# 查看linux已安装字体
fc-list

# 查看linux已安装中文字体
fc-list :lang=zh
</code></pre>

<h2 id="toc_0">安装</h2>

<pre class="line-numbers"><code class="language-bash"># 创建目录
mkdir -p /usr/share/fonts/my_fonts
# 将要安装的字体上传到该文件夹下

# 安装字体索引指令
yum install mkfontscale

# 生成字体索引 进入目录  执行索引字体生成
cd  /usr/share/fonts/my_fonts
mkfontscale

# 查看字体是否安装成功
fc-list :lang=zh

</code></pre>

<h2 id="toc_1">给jdk安装字体</h2>

<p>找到jdk安装路径 找到jre/bin/fonts 文件夹，将字体拷贝到该文件夹下。</p>

<p><img src="media/16425740174242/16427460467899.jpg" alt="" style="width:1125px;"/></p>

<h2 id="toc_2">给openjdk安装字体</h2>

<p>openjdk没有 jre/bin/fonts文件夹。需要自己创建。</p>

<pre class="line-numbers"><code class="language-bash">mkdir -p /jre/bin/fonts/fallback
</code></pre>

<p><img src="media/16425740174242/16427465274847.jpg" alt="" style="width:1146px;"/></p>

<p>来源：<a href="https://wiki.archlinux.org/title/Java_Runtime_Environment_fonts">Java Runtime Environment fonts</a>、<a href="https://www.cnblogs.com/Dy1an/p/9681897.html">CENTOS 7 和 JDK 添加中文字体</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nmap 端口嗅探]]></title>
    <link href="http://565785929.github.io/16415484666630.html"/>
    <updated>2022-01-07T17:41:06+08:00</updated>
    <id>http://565785929.github.io/16415484666630.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16415484666630/16434639294123.jpg" alt=""/></p>

<p>Nmap，也就是Network Mapper，最早是Linux下的网络扫描和嗅探工具包。</p>

<p>很多<a href="https://nmap.org/movies/">影视剧</a>里的黑客工具</p>

<p>nmap 是主机探测、端口扫描、版本检测、系统检测、支持探测脚本编写。查看那个端口和开着啥</p>

<p>telnet 8.8.8.8　　可以查看ip</p>

<p>nmap ip -p<port>　　根据常用服务猜测他的端口，查看ip端口有没有开启</p>

<p>nmap -p50-100 ip　　查看端口范围</p>

<p>nmap -O ip　　　　　操作系统检测</p>

<p>nmap -sP ip　　　　  类似win/linux的ping扫描</p>

<p>nmap -sP ip　　　　</p>

<p>通过 nmap xxx:xxx:xxx:xxx -Pn -p 可以看到端口的启用情况</p>

<p><img src="media/16415484666630/16415487239028.jpg" alt=""/></p>

<p>来源：<a href="https://www.cnblogs.com/wangdadada/p/12024933.html">nmap基本命令使用</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hydra 爆破ssh]]></title>
    <link href="http://565785929.github.io/16415371479168.html"/>
    <updated>2022-01-07T14:32:27+08:00</updated>
    <id>http://565785929.github.io/16415371479168.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16415371479168/16415378538145.jpg" alt=""/></p>

<p>ssh破解神器 <a href="https://github.com/vanhauser-thc/thc-hydra">hydra</a></p>

<p>这是个渗透神器，kail默认安装的工具。</p>

<p>centos 安装步骤： </p>

<pre class="line-numbers"><code class="language-text"># 下载最新版本的 hydra
wget https://github.com/vanhauser-thc/thc-hydra/archive/refs/tags/v9.2.tar.gz

# 解压
tar -xvf v9.2.tar.gz

cd thc-hydra-9.2

# 安装
./configure
make
make install
</code></pre>

<p>之后就可以使用了, 到github下载一个密码本</p>

<pre class="line-numbers"><code class="language-text">git clone https://github.com/huyuanzhi2/password_brute_dictionary.git
</code></pre>

<p>输入命令开始爆破，可以用自己的服务器试试</p>

<pre class="line-numbers"><code class="language-text">./hydra -l root  -P ../../password_brute_dictionary/字母与数字混合/digit_and_letter_top1000.txt -t 1 -vV -e ns  -o save.log  69.165.68.100 ssh
</code></pre>

<p>期间报错的话需要安装cmake</p>

<pre class="line-numbers"><code class="language-text">[ERROR]Compiled without LIBSSH v0.4.x support, module is not available! 
</code></pre>

<pre class="line-numbers"><code class="language-text"># Download CMake from: https://cmake.org/download/
wget https://cmake.org/files/v3.12/cmake-3.12.3.tar.gz

# Compile from source and install
tar zxvf cmake-3.*
cd cmake-3.*
./bootstrap --prefix=/usr/local
make -j$(nproc)
make install

# Validate installation
cmake --version

cmake version *.*.*
CMake suite maintained and supported by Kitware (kitware.com/cmake).
</code></pre>

<p>简单尝试了一下自己的服务器，竟然真的爆破成功了。发现自己竟然用的弱密码，密码里竟然有123，吓得我赶紧生成了一个强密码。服务器安全其实还是应该重视一下的。</p>

<p>来源：<a href="https://www.cnblogs.com/ellisonzhang/p/13440614.html">Centos7安装Hydra(爆破神器) </a>、<a href="https://www.freebuf.com/sectool/159488.html">Linux SSH密码暴力破解技术及攻防实战</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级VUE版本]]></title>
    <link href="http://565785929.github.io/16414626714891.html"/>
    <updated>2022-01-06T17:51:11+08:00</updated>
    <id>http://565785929.github.io/16414626714891.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16414626714891/16434641228384.jpg" alt="" style="width:345px;"/></p>

<p>在看<a href="https://cli.vuejs.org/zh/guide/installation.html">文档</a>中，按步骤升级vue；</p>

<p>于是就先通过 npm uninstall vue-cli -g卸载vue，然后再安装，但是vue -V时依然是2.9.6版本：</p>

<p>第一步：npm config get registry </p>

<p>第二步：npm config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p>

<p>第三步：npm i -g @vue/cli</p>

<p>完美，安装成功！</p>

<p><img src="media/16414626714891/16414627322093.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 目录结构]]></title>
    <link href="http://565785929.github.io/16414407883196.html"/>
    <updated>2022-01-06T11:46:28+08:00</updated>
    <id>http://565785929.github.io/16414407883196.html</id>
    <content type="html"><![CDATA[
<p>启动Linux系统后输入 <code>ls \</code> <br/>
<img src="media/16414407883196/16414408061006.jpg" alt=""/></p>

<p>以下是对这些目录的解释：</p>

<ul>
<li>/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><p>/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li>
<li><p>/dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li>
<li><p>/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li>
<li><p>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li>
<li><p>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li>
<li><p>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li>
<li><p>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li>
<li><p>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li>
<li><p>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li>
<li><p>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p></li>
<li><p>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li>
<li><p>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li>
<li><p>/selinux：这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li>
<li><p>/srv：该目录存放一些服务启动之后需要提取的数据。</p></li>
<li><p>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<ul>
<li>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</li>
<li>该文件系统是内核设备树的一个直观反映。</li>
<li>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li>
</ul></li>
<li><p>/tmp：这个目录是用来存放一些临时文件的。</p></li>
<li><p>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p></li>
<li><p>/usr/bin：系统用户使用的应用程序。</p></li>
<li><p>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</p></li>
<li><p>/usr/src：内核源代码默认的放置目录。</p></li>
<li><p>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li>
</ul>

<p>在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p>

<p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>

<p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p>

<p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的普通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p>

<p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim 跳转技巧]]></title>
    <link href="http://565785929.github.io/16413527990433.html"/>
    <updated>2022-01-05T11:19:59+08:00</updated>
    <id>http://565785929.github.io/16413527990433.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16413527990433/16413528368917.jpg" alt=""/></p>

<p><img src="media/16413527990433/16414412482066.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412884491803.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412867101612.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412866952994.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412886197662.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tmux]]></title>
    <link href="http://565785929.github.io/16408435425370.html"/>
    <updated>2021-12-30T13:52:22+08:00</updated>
    <id>http://565785929.github.io/16408435425370.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16408435425370/16408437247844.jpg" alt=""/></p>

<h2 id="toc_0">安装</h2>

<p>使用包管理工具</p>

<pre class="line-numbers"><code class="language-text"># Ubuntu 或 Debian
$ sudo apt-get install tmux

# CentOS 或 Fedora
$ sudo yum install tmux

# Mac
$ brew install tmux
</code></pre>

<h2 id="toc_1">session 会话管理</h2>

<h3 id="toc_2">1. 新建会话</h3>

<p>第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>

<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>

<pre class="line-numbers"><code class="language-text">$ tmux new -s &lt;session-name&gt;
</code></pre>

<p>上面命令新建一个指定名称的会话。</p>

<h3 id="toc_3">2. 分离会话</h3>

<p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>

<pre class="line-numbers"><code class="language-text">$ tmux detach
</code></pre>

<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>

<p>tmux ls命令可以查看当前所有的 Tmux 会话。</p>

<pre class="line-numbers"><code class="language-text">$ tmux ls
# or
$ tmux list-session
</code></pre>

<h3 id="toc_4">3. 接入会话</h3>

<p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_5">4. 杀死会话</h3>

<p><code>tmux kill-session</code>命令用于杀死某个会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux kill-session -t 0

# 使用会话名称
$ tmux kill-session -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_6">5. 切换会话</h3>

<p><code>tmux switch</code>命令用于切换会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux switch -t 0

# 使用会话名称
$ tmux switch -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_7">6. 重命名会话</h3>

<p><code>tmux rename-session</code>命令用于重命名会话。</p>

<pre class="line-numbers"><code class="language-text">$ tmux rename-session -t 0 &lt;new-name&gt;
上面命令将0号会话重命名。
</code></pre>

<h3 id="toc_8">7. 会话快捷键</h3>

<p>下面是一些会话相关的快捷键。</p>

<pre class="line-numbers"><code class="language-text">Ctrl+b d：分离当前会话。
Ctrl+b s：列出所有会话。
Ctrl+b $：重命名当前会话。
</code></pre>

<h3 id="toc_9">session 总结</h3>

<p>session 在 tmux 操作当中非常重要，希望你可以熟练的使用以上操作：</p>

<p>新建 session -&gt; 离开 session -&gt; 查看 session 列表 -&gt; 进入 session -&gt; 关闭 session -&gt; 不同 session 之间的切换 -&gt; 重命名 session</p>

<pre class="line-numbers"><code class="language-text">tmux new -s &lt;session-name&gt;
tmux detach                                      # Ctrl+b d 
tmux ls                                          # Ctrl+b s
tmux attach -t &lt;session-name&gt; 
tmux kill-session -t &lt;session-name&gt;              # Ctrl+d
tmux switch -t &lt;session-name&gt;
tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;     # Ctrl+b $
</code></pre>

<h2 id="toc_10">pane 窗格管理</h2>

<p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。<br/>
<img src="media/16408435425370/16414372972512.jpg" alt=""/></p>

<h3 id="toc_11">窗格快捷键</h3>

<pre class="line-numbers"><code class="language-text">Ctrl+b %：划分左右两个窗格。
Ctrl+b &quot;：划分上下两个窗格。
Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。
Ctrl+b ;：光标切换到上一个窗格。
Ctrl+b o：光标切换到下一个窗格。
Ctrl+b {：当前窗格与上一个窗格交换位置。
Ctrl+b }：当前窗格与下一个窗格交换位置。
Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。
Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。
Ctrl+b x：关闭当前窗格。
Ctrl+b !：将当前窗格拆分为一个独立窗口。
Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。
Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。
Ctrl+b q：显示窗格编号。
</code></pre>

<h2 id="toc_12">window 窗口管理</h2>

<h3 id="toc_13">窗口快捷键</h3>

<pre class="line-numbers"><code class="language-text">Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。
Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。
Ctrl+b n：切换到下一个窗口。
Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。
Ctrl+b w：从列表中选择窗口。
Ctrl+b ,：窗口重命名。
</code></pre>

<h2 id="toc_14">其他命令</h2>

<pre class="line-numbers"><code class="language-text"># 列出所有快捷键，及其对应的 Tmux 命令
$ tmux list-keys

# 列出所有 Tmux 命令及其参数
$ tmux list-commands

# 列出当前所有 Tmux 会话的信息
$ tmux info

# 重新加载当前的 Tmux 配置
$ tmux source-file ~/.tmux.conf
</code></pre>

<p>来源：<a href="https://zhuanlan.zhihu.com/p/102546608">知乎</a>、<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰的网络日志</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 内存模型]]></title>
    <link href="http://565785929.github.io/16405110285297.html"/>
    <updated>2021-12-26T17:30:28+08:00</updated>
    <id>http://565785929.github.io/16405110285297.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 类加载器]]></title>
    <link href="http://565785929.github.io/16405090873022.html"/>
    <updated>2021-12-26T16:58:07+08:00</updated>
    <id>http://565785929.github.io/16405090873022.html</id>
    <content type="html"><![CDATA[
<p>类的生命周期：</p>

<ul>
<li>加载：找到Class文件</li>
<li>验证：验证格式、依赖</li>
<li>准备：静态字段、方法表</li>
<li>解析：符号解析为引用</li>
<li>初始化：构造器、静态变量赋值、静态代码块</li>
<li>使用</li>
<li>卸载</li>
</ul>

<p><img src="media/16405090873022/16405092178762.jpg" alt="" style="width:402px;"/></p>

<h2 id="toc_0">类的加载时机</h2>

<p><img src="media/16405090873022/16405097616339.jpg" alt="" style="width:735px;"/></p>

<ol>
<li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；</li>
<li>当遇到用以新建目标类示例的new指令时，初始化new指定的目标类，就是new一个类的时候要初始化；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态方法所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射API对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么事已经有实例了，要么是静态方法，都需要初始化；</li>
<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类；</li>
</ol>

<h2 id="toc_1">不会初始化（可能会加载）</h2>

<p><img src="media/16405090873022/16405099836639.jpg" alt="" style="width:733px;"/></p>

<h2 id="toc_2">三类加载器</h2>

<ol>
<li>启动类加载器</li>
<li>拓展类加载器</li>
<li>应用类加载器</li>
</ol>

<p><strong>加载器特点</strong></p>

<ol>
<li>双亲委托</li>
<li>负责依赖</li>
<li>缓存加载</li>
</ol>

<p><img src="media/16405090873022/16405101923617.jpg" alt="" style="width:835px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 字节码]]></title>
    <link href="http://565785929.github.io/16405067982525.html"/>
    <updated>2021-12-26T16:19:58+08:00</updated>
    <id>http://565785929.github.io/16405067982525.html</id>
    <content type="html"><![CDATA[
<p>有一个简单的类 </p>

<pre class="line-numbers"><code class="language-text">class Hello {
        public static void main(String[] agrs) {
                Hello obj = new Hello();
        }
}
</code></pre>

<p>编译：<code>javac Hello.java</code><br/>
查看字节码：<code>javap -c Hello.class</code></p>

<p><img src="media/16405067982525/16405070154518.jpg" alt="" style="width:613px;"/></p>

<p>运算应在栈上操作，所以应该先将变量从本地变量表中加载到栈上，运算完成后再储存回本地变量表。</p>

<p><img src="media/16405067982525/16405072357620.jpg" alt="" style="width:220px;"/></p>

<p>更详细的内容：<code>javap -c -verbose Hello.class</code></p>

<pre class="line-numbers"><code class="language-text">&gt;&gt; javap -c -verbose ./Hello.class

Classfile /Users/sajor/Desktop/jvm/Hello.class
  Last modified 2021-12-26; size 272 bytes
  MD5 checksum ad7dbc8f3a6688a6991501a51cebaa71
  Compiled from &quot;Hello.java&quot;
class Hello
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#13         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #14            // Hello
   #3 = Methodref          #2.#13         // Hello.&quot;&lt;init&gt;&quot;:()V
   #4 = Class              #15            // java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               main
  #10 = Utf8               ([Ljava/lang/String;)V
  #11 = Utf8               SourceFile
  #12 = Utf8               Hello.java
  #13 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V
  #14 = Utf8               Hello
  #15 = Utf8               java/lang/Object
{
  Hello();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class Hello
         3: dup
         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: return
      LineNumberTable:
        line 3: 0
        line 4: 8
}
SourceFile: &quot;Hello.java&quot;
</code></pre>

<p><img src="media/16405067982525/16405076823829.jpg" alt="" style="width:816px;"/></p>

<p>算数操作与类型转换</p>

<p><img src="media/16405067982525/16405079652324.jpg" alt="" style="width:743px;"/></p>

<h2 id="toc_0">小例子：</h2>

<pre class="line-numbers"><code class="language-java">class Hello {
        public static void main(String[] agrs) {
                int a = 2;
                int b = 1;
                int c = a + b * 5;
        }
}
</code></pre>

<p>字节码为如下</p>

<p><img src="media/16405067982525/16405090059683.jpg" alt="" style="width:596px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Final Shell离线激活]]></title>
    <link href="http://565785929.github.io/16402262289586.html"/>
    <updated>2021-12-23T10:23:48+08:00</updated>
    <id>http://565785929.github.io/16402262289586.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16402262289586/16413518433356.jpg" alt=""/></p>

<h2 id="toc_0">使用FinalShell离线激活方式升级高级版本</h2>

<p>使用FinalShell离线激活方式升级高级版本</p>

<p><img src="media/16402262289586/16413519039476.jpg" alt=""/></p>

<p>获取机器码(如果没有就随意输入用户名或密码执行登录)</p>

<p><img src="media/16402262289586/16413519102850.jpg" alt=""/></p>

<p>执行下面代码,输入机器码获取激活码<br/>
<img src="media/16402262289586/16413520061027.jpg" alt=""/></p>

<pre class="line-numbers"><code class="language-text">import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;


class FinalShell {
    public static void main(String[] args) throws NoSuchAlgorithmException, IOException {
        System.out.print(&quot;请输入FinalShell的离线机器码：&quot;);
        Scanner reader = new Scanner(System.in);
        String machineCode = reader.nextLine();
        generateKey(machineCode);
    }

    public static void generateKey(String hardwareId) throws NoSuchAlgorithmException {
        String proKey = transform(61305 + hardwareId + 8552);
        String pfKey = transform(2356 + hardwareId + 13593);
        System.out.println(&quot;请将此行复制到离线激活中：&quot; + proKey);
        System.out.println(pfKey);
    }

    public static String transform(String str) throws NoSuchAlgorithmException {

        String md5 = hashMD5(str);

        return hashMD5(str).substring(8, 24);
    }

    public static String hashMD5(String str) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);
        byte[] hashed = digest.digest(str.getBytes());
        StringBuilder sb = new StringBuilder();
        for (byte b : hashed) {
            int len = b &amp; 0xFF;
            if (len &lt; 16) {
                sb.append(&quot;0&quot;);
            }
            sb.append(Integer.toHexString(len));
        }
        return sb.toString();
    }
}
</code></pre>

<p>成功激活</p>

<p><img src="media/16402262289586/16413520217200.jpg" alt=""/></p>

<p>来源：<a href="http://www.cxyax.com/?post=490">FinalShell 离线激活</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置ssh免密码登陆 不生效]]></title>
    <link href="http://565785929.github.io/16378305266660.html"/>
    <updated>2021-11-25T16:55:26+08:00</updated>
    <id>http://565785929.github.io/16378305266660.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16378305266660/16413525261167.jpg" alt=""/></p>

<h2 id="toc_0">问题：</h2>

<p>设置ssh免密码登陆的时候，发现有一些机器设置不生效。有一些机器正常。</p>

<h2 id="toc_1">跟踪</h2>

<p>登陆目标机器，查看sshd的日志信息。日志信息目录为，/var/log/secure<br/>
你会发现如下字样的日志信息。</p>

<pre class="line-numbers"><code class="language-text">Jul 22 14:20:33 v138020.go sshd[4917]: Authentication refused: bad ownership or modes for directory /home/xinhailong
</code></pre>

<h2 id="toc_2">原因</h2>

<p>sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。<br/>
用户目录权限为 755 或者 700，就是不能是77x。<br/>
.ssh目录权限一般为755或者700。<br/>
rsa_id.pub 及authorized_keys权限一般为644<br/>
rsa_id权限必须为600</p>

<h2 id="toc_3">解决方法</h2>

<p>检测目录权限，把不符合要求的按要求设置权限即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 更新 node 版本]]></title>
    <link href="http://565785929.github.io/16353269752301.html"/>
    <updated>2021-10-27T17:29:35+08:00</updated>
    <id>http://565785929.github.io/16353269752301.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16353269752301/16413526184515.jpg" alt=""/></p>

<p>第一步，先查看本机node.js版本：</p>

<p>node -v</p>

<p>第二步，清除node.js的cache：</p>

<p>sudo npm cache clean -f</p>

<p>第三步，安装 n 工具，这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 &quot;n&quot;</p>

<p>sudo npm install -g n</p>

<p>第四步，安装最新版本的node.js</p>

<p>sudo n stable</p>

<p>第五步，再次查看本机的node.js版本：</p>

<p>node -v</p>

<p>第六步，更新npm到最新版：</p>

<p>$ sudo npm install npm@latest -g</p>

<p>第七步，验证</p>

<p>node -v<br/>
npm -v</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[join 语句]]></title>
    <link href="http://565785929.github.io/16351769421565.html"/>
    <updated>2021-10-25T23:49:02+08:00</updated>
    <id>http://565785929.github.io/16351769421565.html</id>
    <content type="html"><![CDATA[
<p>I</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14 | count(*)这么慢，我该怎么办？]]></title>
    <link href="http://565785929.github.io/16345712700520.html"/>
    <updated>2021-10-18T23:34:30+08:00</updated>
    <id>http://565785929.github.io/16345712700520.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">count(*) 的实现方式</h2>

<p>你首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>

<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>

<p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。</p>

<h2 id="toc_1">计数的几种方式</h2>

<ul>
<li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>

<h2 id="toc_2">不同的 count 用法</h2>

<p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>

<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>

<ul>
<li>server 层要什么就给什么；</li>
<li>InnoDB 只给必要的值；</li>
<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>
</ul>

<p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>

<p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>

<p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>

<p><strong>对于 count(字段) 来说</strong>：</p>

<ol>
<li><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</p></li>
<li><p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p></li>
</ol>

<p>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</p>

<p><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[13 重构数据库]]></title>
    <link href="http://565785929.github.io/16345707563290.html"/>
    <updated>2021-10-18T23:25:56+08:00</updated>
    <id>http://565785929.github.io/16345707563290.html</id>
    <content type="html"><![CDATA[
<p>GitHub&#39;s Online Schema Migrations for MySQL<br/>
(<a href="https://github.com/github/gh-ost">https://github.com/github/gh-ost</a>)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 系统的启动过程]]></title>
    <link href="http://565785929.github.io/16343110664613.html"/>
    <updated>2021-10-15T23:17:46+08:00</updated>
    <id>http://565785929.github.io/16343110664613.html</id>
    <content type="html"><![CDATA[
<ul>
<li>内核的引导</li>
<li>运行init</li>
<li>系统初始化</li>
<li>建立终端 </li>
<li>用户登录系统</li>
</ul>

<p><img src="media/16343110664613/16343111820817.jpg" alt=""/></p>

<h2 id="toc_0">内核引导</h2>

<p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>

<p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>

<h2 id="toc_1">运行init</h2>

<p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>

<p>init 程序首先是需要读取配置文件 /etc/inittab。</p>

<h2 id="toc_2">运行级别</h2>

<p>许多程序需要开机启动。它们在Windows叫做&quot;服务&quot;（service），在Linux就叫做&quot;守护进程&quot;（daemon）。</p>

<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>

<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>

<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;（runlevel）。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p>

<p><strong>Linux系统有7个运行级别(runlevel)：</strong></p>

<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栈 队列 双端队列（Stack & Queue & Deque）]]></title>
    <link href="http://565785929.github.io/16341349844977.html"/>
    <updated>2021-10-13T22:23:04+08:00</updated>
    <id>http://565785929.github.io/16341349844977.html</id>
    <content type="html"><![CDATA[
<p><a href="http://www.bigocheatsheet.com">www.bigocheatsheet.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[numpy]]></title>
    <link href="http://565785929.github.io/16339276945488.html"/>
    <updated>2021-10-11T12:48:14+08:00</updated>
    <id>http://565785929.github.io/16339276945488.html</id>
    <content type="html"><![CDATA[
<p>用于高性能科学计算和数据分析，是常用的高级数据分析库的基础包</p>

<h1 id="toc_0">pandas</h1>

]]></content>
  </entry>
  
</feed>
