<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2021-07-04T00:39:35+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[为什么需要版本控制]]></title>
    <link href="http://565785929.github.io/16253298632146.html"/>
    <updated>2021-07-04T00:31:03+08:00</updated>
    <id>http://565785929.github.io/16253298632146.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概述</h2>

<p>在软件开发过程，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：</p>

<ul>
<li>  代码被覆盖或丢失</li>
<li>  代码写的不理想希望还原之前的版本</li>
<li>  希望知道与之前版本的差别</li>
<li>  是谁修改了代码以及为什么修改</li>
<li>  发版时希望分成不同的版本(测试版、发行版等)</li>
</ul>

<p>因此，我们希望有一种机制，能够帮助我们：</p>

<ul>
<li>  可以随时回滚到之前的版本</li>
<li>  协同开发时不会覆盖别人的代码</li>
<li>  留下修改记录，以便随时查看</li>
<li>  发版时可以方便的管理不同的版本</li>
</ul>

<h2 id="toc_1">什么是版本控制系统</h2>

<p>一个标准的版本控制系统 Version Control System (VCS)，通常需要有以下功能：</p>

<ul>
<li>  能够创建 Repository (仓库)，用来保存代码</li>
<li>  协同开发时方便将代码分发给团队成员</li>
<li>  记录每次修改代码的内容、时间、原因等信息</li>
<li>  能够创建 Branch (分支)，可以根据不同的场景进行开发</li>
<li>  能够创建 Tag (标签)，建立项目里程碑</li>
</ul>

<h2 id="toc_2">什么是Svn</h2>

<p><img src="media/16253298632146/16253300167643.jpg" alt=""/></p>

<p>Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</p>

<p>日常开发过程其实就是这样的（假设你已经Checkout并且已经工作了几天）：</p>

<ol>
<li>Update(获得最新的代码) --&gt;</li>
<li>作出自己的修改并调试成功 --&gt; </li>
<li>Commit(大家就可以看到你的修改了) </li>
</ol>

<p>如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict, 冲突，需要手动确认。</p>

<h2 id="toc_3">什么是Git</h2>

<p><img src="media/16253298632146/16253299182713.jpg" alt=""/></p>

<ul>
<li>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li>
<li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li>
<li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</li>
</ul>

<h2 id="toc_4">版本控制系统的发展史</h2>

<p>版本控制系统发展至今有几种不同的模式：</p>

<h3 id="toc_5">Local VCS</h3>

<p>本地使用 <code>复制/粘贴</code> 的方式进行管理，缺点是无法协同开发</p>

<h3 id="toc_6">Centralized VCS (Lock，悲观锁)</h3>

<p>中央集中式版本控制系统团队共用仓库，当某人需要编辑文件时，进行锁定，以免其他人同时编辑时造成冲突。缺点是虽然避免了冲突，但不是很方便。其他人需要排队才能编辑文件，如果有人编辑了很久或是忘记解锁就会造成其他人长时间等待的情况。</p>

<h3 id="toc_7">Centralized VCS (Merge，乐观锁)</h3>

<p>中央集中式版本控制系统团队共用仓库，不采用悲观锁方式来避免冲突，而是事后发现如果别人也修改相同文件(冲突)，再进行手动修改解决。有很多 VCS 属于这种类型，如：CVS，Subversion，Perforce 等</p>

<p>中央集中式版本控制系统的共同问题是，做任何操作都需要和服务器同步，如果服务器宕机则会造成无法继续工作的窘迫。</p>

<h3 id="toc_8">Distributed VCS</h3>

<p>分布式版本控制系统，本地也拥有完整的代码仓库，就不会出现上述集中式管理的问题，即使没有网络，依然可以 <code>commit</code> 和看 <code>log</code>，也无需担心服务器同步问题。如：Git，Mercurial，Bazaar 等就属于分布式版本控制系统。缺点是功能比较复杂，上手需要一定的学习时间。</p>

<p>本教程来自<a href="https://www.funtl.com/zh/git/">千锋教育-李卫民</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见Git仓库]]></title>
    <link href="http://565785929.github.io/16253295942611.html"/>
    <updated>2021-07-04T00:26:34+08:00</updated>
    <id>http://565785929.github.io/16253295942611.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">GitHub</h2>

<h2 id="toc_1">GitLab</h2>

<p><img src="media/16253295942611/16253303567762.jpg" alt=""/></p>

<p><a href="http://bdgit.eigpay.com/">http://bdgit.eigpay.com/</a></p>

<p>git是一个版本管理软件，由linux之父花了三天搞出来的东西，他没有界面，只支持命令行。</p>

<p>github是一个网站，因为git没有图形界面，github它支持在线的几乎所有git的操作，最重要它也是一个包含了很多程序员的开源社区。</p>

<p>gitlib 是用于实现git功能的开发库</p>

<p>gitlab提倡开源，如果你不想开源就要花钱，你如果不愿意花钱，就自己搞个服务器，装gitlab这个软件来实现自己的版本控制，有点私服的概念。</p>

<p>作者：笑笑酱丶<br/>
链接：<a href="https://www.jianshu.com/p/26fa7df41c9a">https://www.jianshu.com/p/26fa7df41c9a</a><br/>
来源：简书<br/>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ray Tracing for one week]]></title>
    <link href="http://565785929.github.io/16197951416649.html"/>
    <updated>2021-04-30T23:05:41+08:00</updated>
    <id>http://565785929.github.io/16197951416649.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[科学上网]]></title>
    <link href="http://565785929.github.io/16137917098988.html"/>
    <updated>2021-02-20T11:28:29+08:00</updated>
    <id>http://565785929.github.io/16137917098988.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16137917098988/16193973348755.jpg" alt="" style="width:150px;"/></p>

<h2 id="toc_0">背景</h2>

<p>自从天朝有了言论管制，科学上网的话题就一直存在，于是大量的梯子软件应运而生。但是GFW与这些梯子软件的斗争从来都没有停止过，一直是此消彼长，墙越来越高，科学上网技术也是持续突破，不断涌现出新技术、新工具。现在最主流的科学上网技术有VPN/SS/SSR/V2Ray/Trojan/Trojan-Go，还有小众的 WireGuard、Brook、Snell 和 NaiveProxy 等，本篇文章不讨论Brook、NaiveProxy以及Snell协议。SS是科学上网代理协议的鼻祖，Snell和Brook是小众协议，Snell协议一直没有开源，是iOS平台非常知名的Surge软件团队开发的专属协议，Brook配套设施不完善；其中，VPN/SS/SSR最为出名，V2Ray和Trojan/Trojan-Go作为新星，正在受到越来越多的关注和使用。</p>

<h2 id="toc_1">什么是VPN和WireGuard，它们有什么关系？</h2>

<p>VPN是英文 Virtual Private Network 的缩写，中文名称为虚拟专用网络，是一种加密通信技术。VPN 只是一个统称，它有很多的具体实现，比如PPTP、L2TP、IPSec和OpenVPN等。VPN是在公用网络上建立专用网络，并对通信进行加密，防止传输数据被识别或篡改，以保障通信的安全。当你在VPN网络中通信，就相当于通过物理的内网专线进行通信。由此可见，VPN绝不是为了科学上网而生，而是更加注重数据信息的安全，很多大型企业和高校的远程SOHO办公使用VPN较多。</p>

<p>WireGuard 是最新开发的VPN协议，比主流的VPN技术有明显优势，被誉为下一代VPN。WireGuard有如下特点：</p>

<p>WireGuard 的优点：</p>

<ul>
<li>更轻便：以Linux内核模块的形式运行，资源占用小。</li>
<li>更高效：相比目前主流的IPSec、OpenVPN等VPN协议，WireGuard的效率要更高。</li>
<li>更快速：比目前主流的VPN协议，连接速度要更快。</li>
<li>更安全：使用了更先进的加密技术。</li>
<li>更易搭建：部署难度相对更低。</li>
<li>更隐蔽：以UDP协议进行数据传输，比TCP协议更低调。</li>
<li>不易被封锁：TCP阻断对WireGuard无效，IP被墙的情况下仍然可用。</li>
<li>更省电：不使用时不进行数据传输，移动端更省电。</li>
</ul>

<p>WireGuard 的不足：</p>

<ul>
<li>处于研发初期，各种功能及支持有待完善。</li>
<li>由于使用UDP协议，BBR、锐速等TCP网络加速工具，对WireGuard无效。</li>
<li>部分运营商可能会对UDP协议进行QOS限速，WireGuard会受到一定影响。</li>
<li>客户端分流功能较弱，对GFWList的支持不足。</li>
</ul>

<p>WireGuard虽然有一些不足，但WireGuard的优点更突出，而且可以拯救被封IP的VPS，所以 WireGuard 是 SS/SSR/V2Ray/Trojan 等代理工具之外的一个不错的选择。</p>

<h2 id="toc_2">什么是 Shadowsocks？</h2>

<p>SS 是 Shadowsocks 的缩写，中文名为影梭，为了避免关键词过滤，网友喜欢将 Shadowsocks 称为“酸酸”，是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。Shadowsocks 由 Clowwindy 为了自己使用谷歌查资料而编写，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。后来，他觉得这个东西非常好用、速度也很快，于是他在 GitHub 上共享了源码。在天朝，本工具被广泛用于突破GFW，以浏览被封锁、遮蔽或干扰的内容，由于 Shadowsocks 被广泛传播，导致作者被请去喝茶。2015年8月22日，Shadowsocks 原作者 Clowwindy 称迫于天朝内部的压力，宣布停止维护此计划（项目），并移除其个人页面所存储的源代码，而且保证永不再参与维护更新。值得庆幸地是，Shadowsocks 仍然有不少国外社区成员在维护更新。后来贡献者Librehat也为Shadowsocks补上了一些数据混淆类特性，甚至增加了类似Tor的可插拔传输层功能。</p>

<h2 id="toc_3">什么是 ShadowsocksR</h2>

<p>SSR 是 ShadowsocksR 的缩写，网民爱称“酸酸乳”，是在 Shadowsocks 的作者被请去喝茶之后，网名为breakwa11的用户发起的Shadowsocks的一个分支版本，它在Shadowsocks的基础上增加了一些数据混淆方式，修复了部分安全问题并提高QoS优先级。由于 ShadowsocksR 在协议和混淆方面做了改进，更加不容易被GFW检测到，而且兼容原 Shadowsocks，并为新项目取名叫 Shadowsocks-R，一开始部分代码由社区人员进行更新。由于不完全开源，也导致后来使用 SS 和 SSR 的用户分成两个阵营，互相撕逼，直到开发者 Breakwa11(破娃) 被人肉出来。Breakwa11(破娃)最终决定删除 Shadowsocks-R 项目的所有代码，并解散了所有相关群组。</p>

<p>事件始末澄清：ShadowsocksR 的作者一开始曾有过违反GPL，在发布二进制文件时不开放源码的争议。不过后来 Shadowsocks-R 项目由 breakwa11 采用了与 Shadowsocks 相同的GPL、Apache许可证、MIT许可证等多重自由软件许可协议。</p>

<p>2017年7月19日，ShadowsocksR 作者 breakwa11 在Telegram频道 ShadowsocksR news 里转发了深圳市启用SS协议检测的消息并被大量用户转发，在TG圈引发恐慌。7月24日，breakwa11 发布了闭源的SS被动检测程序，引发争议。7月27日，breakwa11 遭到自称 “ESU.TV” 的不明身份人士人身攻击，对方宣称如果不停止开发并阻止用户讨论此事件将发布更多包含个人隐私的资料，随后 breakwa11 表示遭到对方人肉搜索并公开个人资料的是无关人士。为了防止对方继续伤害无关人士，breakwa11 将删除GitHub上的所有代码、解散相关交流群组，并停止 ShadowsocksR 项目。</p>

<p>从本质上说，Shadowsocks 和 ShadowsocksR 的基本原理相同，都是基于 socks5 的代理工具，只在本地客户端和服务器端对数据包加解密，然后使用 socks5 协议转发加密的数据包，而不用在乎使用什么协议，所以 Socks5 代理比其他应用层代理速度要快得多。</p>

<h2 id="toc_4">【科普】什么是 socks5 代理？</h2>

<p>socks5 代理的原理是把你的网络数据请求先发送到你的代理服务器，然后由代理服务器转发给目标；如果目标有反馈发送到代理服务器，那么代理服务器会将数据包直接传回你的本地网络，整个过程只是数据的二次传输，并没有做额外的处理。比如，现在你在深圳，你的代理服务器在日本，如果你想要访问Google，那么你首先要把数据请求通过本地 socks5 代理客户端发给你在香港的服务器上的 socks5 代理服务端，然后你在香港的服务器将数据请求发送给Google，再把Google反馈的结果传回你的本地电脑的 socks5 客户端，这样就可以绕开GFW的检测而实现科学上网。</p>

<p>显而易见，socks5代理的所有数据走的仍然是公网，而且在公网传输过程中，没有对数据进行任何加密和混淆，这跟VPN在公网建立虚拟专用通道传输过程中，对数据高强度加密的方式完全不同。Shadowsocks 和 ShadowsocksR 只在客户端和服务器端对数据做了简单加密和认证，主要功能是流量转发，过墙才是主要目的。虽然现在 ShadowsocksR 已经停止更新很久了，而 Shadowsocks 仍处于社区人员的更新维护之中，不断修复漏洞并增加新功能，所以现在 Shadowsocks 比 ShadowsocksR 更强大。</p>

<p><strong>我在此提醒大家</strong>：请不要迷信 SSR 一定比 SS 强，也包括现在的V2Ray、Trojan，甚至WireGuard等，因为增加混淆意味着损失速度，混淆加密越是强悍，那么其速度和稳定性损失就越大，另外 SSR 至今已经被研究透了，而且长期没有更新维护，其流量特征是可以被GFW精准识别的，所以用 SSR 跟用 SS 没有本质区别，由于SS一直在更新维护，反而更稳定。我们要做的就是爱国爱家爱生活，勿谈国是，专心做好自己的事情就是了。天朝一直都清楚，跨境相关业务一直存在，尤其是近些年跨境电商的蓬勃发展，很多做跨境相关业务的朋友不外出通讯是不可能的一件事情，但所谓的公司备案VPN却非常昂贵，一般用户根本承担不起费用。但我们一定要“做好分内事，勿论他人非”，尤其不发表涉及天朝的言论和行为，做一个天朝的好公民、中华的好儿女，这样天朝是没有必要跟她的好儿女过不去的。</p>

<h2 id="toc_5">什么是 V2Ray？</h2>

<p>V2Ray 是在Shadowsocks 被封杀之后，为了表示抗议而开发的，属于后起之秀，功能更加强大，为抗GFW封锁而生。V2Ray 现在已经是 Project V 项目的核心工具，而 Project V 是一个平台，其中也包括支持 Shadowsocks 协议。由于 V2Ray 早于 Project V 项目，而且名声更大，所以我们习惯称 Project V 项目为 V2Ray，所以我们平时所说的 V2Ray 其实就是 Project V  这个平台，也就是一个工具集。其中，只有 VMess协议是V2Ray社区原创的专属加密通讯协议，被广泛应用于梯子软件。</p>

<p>V2Ray目前支持以下协议（截止到2019年12月）：</p>

<ul>
<li>Blackhole：中文名称“黑洞”，是一个出站数据协议，它会阻碍所有数据的出站，配合路由（Routing）一起使用，可以达到禁止访问某些网站的效果。</li>
<li>Dokodemo-door：中文名称“任意门”，是一个入站数据协议，它可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。</li>
<li>Freedom：是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。</li>
<li>HTTP：超文本传输协议，是传统的代理协议</li>
<li>MTProto：Telegram 的开发团队开发的专用协议，是一个 Telegram 专用的代理协议。在 V2Ray 中可使用一组入站出站代理来完成 Telegram 数据的代理任务。目前只支持转发到 Telegram 的 IPv4 地址。</li>
<li>Shadowsocks：最早被个人开发的科学上网梯子协议，但 V2Ray 目前不支持 ShadowsocksR。</li>
<li>Socks：标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5，也是传统的代理协议。</li>
<li>VMess：是V2Ray 专用的加密传输协议，它分为入站和出站两部分，通常作为 V2Ray 客户端和服务器之间的桥梁。因为增加了混淆和加密，据说比 Shadowsocks 更安全。现在的机场支持 V2Ray，一般是指支持 VMess 协议。VMess 依赖于系统时间，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。</li>
</ul>

<p>截止到2019年12月，V2Ray 可选的传输层配置有：TCP、mKCP、WebSocket、HTTP/2、DomainSocket、QUIC。其中，mKCP、QUIC和TCP用于优化网络质量；WebSocket用于伪装；HTTP/2和DomainSocket用于传输以及TLS加密。</p>

<p>V2Ray不仅可以在传输层配置 TLS 使 HTTP 和 SOCKS 变成 HTTPS 和 SOCKS over TLS 协议，也可以使MTProto、Shadowsocks 和 VMess 通过传输层配置TLS加密伪装成 TLS 流量。所以，VMess 配置 TLS 加密是最常见的做法，但没人会对 Shadowsocks 使用 TLS 加密，因为这完全没意义。</p>

<h2 id="toc_6">什么是 Trojan/Trojan-Go？</h2>

<p>Trojan，原来多是指特洛伊木马，是一种计算机病毒程序。但是，我们今天所说的Trojan是一种新的科学上网技术，全称为Trojan-GFW，是目前最成功的科学上网伪装技术之一。你可以认为Trojan是V2Ray的“WS+TLS”模式的精简版，速度比V2Ray更快，伪装比V2Ray更逼真，更难以被GFW识别。</p>

<p>Trojan工作原理：Trojan通过监听443端口，模仿互联网上最常见的 HTTPS 协议，把合法的Trojan代理数据伪装成正常的 HTTPS 通信，并真正地完整完成的TLS 握手，以诱骗GFW认为它就是 HTTPS，从而不被识别。Trojan处理来自外界的 HTTPS 请求，如果是合法的，那么为该请求提供服务，否则将该流量转交给Caddy、Nginx等 web 服务器，由 Caddy、Nginx 等为其提供网页访问服务。基于整个交互过程，这样能让你的VPS更像一个正常的web服务器，因为Trojan的所有行为均与 Caddy、Nginx等 web 服务器一致，并没有引入额外特征，从而达到难以识别的效果。</p>

<p>Trojan-Go是Trojan-GFW的分支项目，对Trojan进行性能优化，并增加不少新功能，Trojan-Go性能和功能均有大幅度的提升，而且支持分流和CDN。</p>

<h2 id="toc_7">什么是Xray？</h2>

<p>Xray与V2Ray完全类同，Xray 是 Project X 项目的核心模块。因为Xray和XTLS黑科技的作者rprx曾经是V2fly社区的重要成员，所以Xray直接Fork全部V2Ray的功能，然后进行性能优化，并增加了新功能，使Xray在功能上成为了V2Ray的超集，且完全兼容V2Ray。</p>

<p>简而言之，Xray是V2Ray的项目分支，Xray是V2Ray的超集，就跟Trojan-Go和Trojan-GFW的关系类似，而且Xray性能更好、速度更快，更新迭代也更频繁。由于自V2ray-core 4.33.0 版本起，删除了XTLS黑科技，但仍然支持VLESS，所以是否原生支持XTLS是Xray和V2Ray最大的区别之一。</p>

<h2 id="toc_8">VPN、SS/SSR、V2Ray/Xray 和 Trojan/Trojan-Go 之间有什么区别及优缺点</h2>

<h3 id="toc_9">（1）原理不同</h3>

<p>VPN强调对公网传输过程中数据的加解密，SS/SSR/V2Ray/Xray/Trojan都是专注于在客户端和服务器端加解密，公网传输数据过程中特征没有VPN明显。</p>

<h3 id="toc_10">（2）目的不同</h3>

<p>VPN是走在公网中自建的虚拟专用通道，使用强大的加解密算法，为数据传输安全性、私密性而生，被广泛应用于企业、高校、科研部门等远程数据传输的领域；SS/SSR/V2Ray/Xray/Trojan/Trojan-Go是为了数据能够安全通过GFW而生，更强调的是对数据的混淆和伪装，加解密只是为了更好的隐藏数据特征而顺利绕过GFW的检测，数据内容加密可以有效绕过关键词的检测。</p>

<p>在天朝，如果你想用VPN翻墙几乎是不可能的，在平时不怎么限制还好，特殊时期VPN是断流最惨的。如果要需要匿名安全上网，VPN+TOR或SS/SSR+TOR也是不错的选择。当然，现在已经有了新的对抗技术，比如V2Ray/Xray、Trojan/Trojan-Go、WireGuard等。另外，有一些比较著名的工具，如红杏出墙、蓝灯（Lantern）、Tor Browser、赛风3（Psiphon3）等，都相继被墙，现在已经很少人使用了。</p>

<h2 id="toc_11">项目诞生的大致时间顺序</h2>

<p>VPN &gt; SS &gt; SSR/V2Ray/WireGuard &gt; Trojan/Trojan-Go &gt; Xray</p>

<h2 id="toc_12">对梯子软件/科学上网工具的总结</h2>

<p>VPN虽然天生不是为了做梯子，但却是最出名的梯子软件、众人皆知的科学上网工具，但是由于VPN特征太明显，现在非大陆正规公司的VPN基本被禁的差不多了；SS/SSR为科学上网而生，但是加密和混淆较弱，而且已经被GFW精准识别，在科学上网方面的前景堪忧，但是仍然适用于专线，网络速度比V2Ray/Trojan/Trojan-Go更快；V2Ray/Xray为科学上网而生，天生不凡，已经成长为一个平台框架，拥有自研协议VMess和VLESS，功能非常强大；WireGuard被誉为新一代VPN，技术强大，而且已经被写入Linux内核，前景光明，但是在科学上网方面并不够隐蔽，所以不是未来主流的科学上网工具；Trojan/Trojan-Go为科学上网而生，天生只为了模仿互联网最流行的HTTPS协议而存在，是目前最成功的伪装工具之一，功能与V2Ray的“Vmess+WS+TLS”模式相当，但是更轻量，伪装更逼真，目前GFW几乎无法识别其特征，而且目前Trojan-Go在性能和速度方面的表现均优于V2Ray的VMess和VLESS协议。所以，我认为Trojan/Trojan-Go会跟V2Ray一样成为将来科学上网的主流工具之一，SSR由于长期得不到维护而逐渐退出历史舞台，Shadowsocks/SS依然是最轻量的科学上网代理协议，没有之一。</p>

<p><a href="https://iyideng.me/black-technology/cgfw/vpn-ss-ssr-v2ray-trojan-wireguard-bypass-gfw.html">来源</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动登录工具开发]]></title>
    <link href="http://565785929.github.io/16110385786886.html"/>
    <updated>2021-01-19T14:42:58+08:00</updated>
    <id>http://565785929.github.io/16110385786886.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">涉及工具技术</h2>

<ul>
<li>Tampermonkey</li>
<li>jQuery</li>
<li>Tesseract-OCR</li>
<li>Flask</li>
<li><a href="https://pillow.readthedocs.io/en/stable/">Pillow</a></li>
</ul>

<h2 id="toc_1">前言</h2>

<p>开发软件系统时必然会有用户登陆的模块。每次验证自己的功能时，总是绕不开输入账号密码，这已经是很麻烦的了，还得输入不好辨认的验证码。</p>

<p>为了简化登陆步骤，我通过使用图像识别 OCR 技术，和Web应用框架Flask搭建一个验证码自动识别的服务。并结合强大的浏览器插件Tampermonkey，编写一个简单的油猴脚本，在不入侵源系统的基础上，实现不输入验证码登陆。也为后期自动化测试奠定可操作的基础。</p>

<h2 id="toc_2">依赖安装</h2>

<p>示例环境Centos8</p>

<pre class="line-numbers"><code class="language-bash">sudo yum install epel-release
sudo yum install tesseract-devel leptonica-devel
 
yum install -y libjpeg-devel  libpng-devel
yum install -y autoconf automake libtool

yum install -y git wget
yum install -y gcc gcc-c++
yum install -y tesseract  tesseract-devel  
yum install -y python36
</code></pre>

<p>创建python虚拟环境</p>

<pre class="line-numbers"><code class="language-bash">python3.6 -m venv py36env
source py36env/bin/activate
</code></pre>

<p>python依赖安装</p>

<pre class="line-numbers"><code class="language-bash">pip install flask
pip install flask_cors
pip install tesserocr
pip install pillow
pip install uwsgi
</code></pre>

<h2 id="toc_3">安装常见错误</h2>

<p><strong>找不到tesseract包</strong></p>

<blockquote>
<p>yum list tesseract <br/>
无数据 </p>
</blockquote>

<p><strong>解决</strong></p>

<pre class="line-numbers"><code class="language-text">yum -y install yum-utils
yum-config-manager --add-repo https://download.opensuse.org/repositories/home:/Alexander_Pozdnyakov/CentOS_8/
</code></pre>

<p><strong>TESSDATA_PREFIX问题</strong></p>

<blockquote>
<p>[Sajor@10-7-151-243 AutoLogin]$ tesseract captcha_denoising.png result <br/>
Error opening data file /usr/share/tesseract/4/tessdata/eng.traineddata<br/>
Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.<br/>
Failed loading language &#39;eng&#39;<br/>
Tesseract couldn&#39;t load any languages!<br/>
Could not initialize tesseract.</p>
</blockquote>

<p><strong>解决</strong></p>

<p>搜索tessdata文件夹 </p>

<pre class="line-numbers"><code class="language-text">find / -type d -iname &quot;tessdata&quot;
</code></pre>

<p>发现确实没有 <code>eng.traineddata</code> 文件，则下载一个。</p>

<pre class="line-numbers"><code class="language-text">wget https://github.com/tesseract-ocr/tessdata/raw/master/eng.traineddata

sudo mv -v eng.traineddata /usr/local/share/tessdata/
</code></pre>

<h2 id="toc_4">验证码识别</h2>

<p>我们开发的系统登陆页面是这样的</p>

<p><img src="media/16110385786886/16110394454445.jpg" alt="" style="width:814px;"/></p>

<p>其中验证码图片<br/>
<img src="media/16110385786886/captcha3.png" alt="captcha3"/></p>

<p>先分析此验证码图片有以下特点</p>

<ul>
<li>颜色多样</li>
<li>字母较大，干扰线细</li>
<li>线条笔直无扭曲</li>
</ul>

<p>我们可以这样处理</p>

<h3 id="toc_5">颜色多样</h3>

<p>针对颜色多样，我们可以先给图片做灰度处理再做二值化处理，这是识别前处理验证码的基操。</p>

<blockquote>
<p><strong>灰度图像</strong>: 每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。<br/>
<strong>转换公式</strong>: <code>L = R * 299/1000 + G * 587/1000+ B * 114/1000</code></p>
</blockquote>

<pre class="line-numbers"><code class="language-text">from PIL import Image
image = Image.open(file).convert(&#39;L&#39;)
</code></pre>

<p><img src="media/16110385786886/16110398931116.jpg" alt="" style="width:323px;"/></p>

<p>之后对灰度图片做二值化，使图片非黑即白，可以通过调整下图中<code>threshold</code>的值来过滤少部分颜色浅的干扰线，因为图片中字母部分也可能出现亮黄色的情况，为了防止误删要识别的文字，我将阈值先调高一些，少过滤一些颜色。</p>

<blockquote>
<p><strong>二值图像</strong>: 非黑即白。每个像素用8个bit表示，0表示黑，255表示白。</p>

<pre class="line-numbers"><code class="language-text">image.convert(&#39;1&#39;)
</code></pre>
</blockquote>

<p><img src="media/16110385786886/16110403706745.jpg" alt="" style="width:523px;"/></p>

<h3 id="toc_6">字母较大，干扰线细</h3>

<p>因为字母较大，像素较多，而干扰线的较细，我们可以使用这个策略来去除干扰线。</p>

<pre class="line-numbers"><code class="language-text">遍历图片中每一个像素点：
    如果这个像素点为黑色：
        观察它四面八方的像素点颜色，如果少于四个点为黑色：
            将这个点变为白色
</code></pre>

<p>这个策略的大致意思就是将图像中置于边缘的像素删除掉。因为字母较大，像素比较多，删除一圈也不会有什么影响。</p>

<p><img src="media/16110385786886/16110409153447.jpg" alt="" style="width:310px;"/></p>

<h3 id="toc_7">线条笔直无扭曲</h3>

<p>通过上一步的降噪处理得到的结果已经很好了，因为线条笔直没有扭曲，可以直接丢给OCR来识别了！</p>

<p>网络中现成的OCR识别工具有很多，比如百度OCR，Tesseract-OCR。</p>

<p>第三方的OCR得经过注册，使用他们提供的token调用接口，我就直接使用Python的第三方库Tesseract来搞。</p>

<p>安装必要的包之后直接调用即可。</p>

<pre class="line-numbers"><code class="language-text">import tesserocr
result = tesserocr.image_to_text(image)
</code></pre>

<p><img src="media/16110385786886/16110413762073.jpg" alt="" style="width:360px;"/></p>

<h2 id="toc_8">编写Web接口</h2>

<p>使用Jupyter notebook 验证好功能后，将代码封装成类，方便调用。</p>

<p>之后使用Flask的 helloworld 工程简单修改一下，实现一个可调用的接口。</p>

<p>简单实用<code>uwsgi</code>部署一下这个web项目，配置<code>uwsgi.ini</code>文件将下文中<code>/root/AutoLogin</code>路径改为自己的目录。</p>

<pre class="line-numbers"><code class="language-text">[uwsgi]
master = true
http=:5000
chdir = /root/AutoLogin
wsgi-file=/root/AutoLogin/app.py
callable=app
processes=4
threads=2
buffer-size = 65536
vacuum=true
pidfile =/root/AutoLogin/uwsgi.pid
</code></pre>

<p>启动命令：<br/>
<code>uwsgi --ini uwsgi.ini</code><br/>
重启命令：<br/>
<code>uwsgi --reload uwsgi.pid</code><br/>
关闭命令：<br/>
<code>uwsgi --stop uwsgi.pid</code></p>

<h2 id="toc_9">NginX代理</h2>

<p>新建一个配置文件</p>

<pre class="line-numbers"><code class="language-text">vi /etc/nginx/conf.d/autologin.conf
</code></pre>

<p>输入以下内容</p>

<pre class="line-numbers"><code class="language-text">        server{

                listen       80;
                listen       [::]:80;
                server_name  autoLogin.sajor.top;
                access_log  /var/log/nginx/access.log;
                error_log   /var/log/nginx/error.log;

                location /{
                        proxy_pass http://localhost:5000;
                }
        }
</code></pre>

<p>检查并重启</p>

<pre class="line-numbers"><code class="language-text">nginx -t
service nginx restart
</code></pre>

<p>查看 mem top 10</p>

<pre class="line-numbers"><code class="language-text">ps aux | grep -v PID | sort -rn -k 4| head
</code></pre>

<h2 id="toc_10">--</h2>

<p>-- 未完待续。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql5.7 无法设置0000-00-00默认日期]]></title>
    <link href="http://565785929.github.io/16022150270617.html"/>
    <updated>2020-10-09T11:43:47+08:00</updated>
    <id>http://565785929.github.io/16022150270617.html</id>
    <content type="html"><![CDATA[
<p>问题：<br/>
<img src="media/16022150270617/16125316270697.jpg" alt=""/></p>

<p><img src="media/16022150270617/16125316380058.jpg" alt=""/></p>

<p>使用命令行。navicat不好使</p>

<h2 id="toc_0">解决方案：</h2>

<p>使用root登陆数据库</p>

<ol>
<li>查看sql_mode：
<code>select @@sql_mode;</code></li>
</ol>

<p>获得结果：<br/>
<code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<ol>
<li>NO_ZERO_IN_DATE,NO_ZERO_DATE是无法默认为‘0000-00-00 00:00:00’的根源，去掉之后再次新建表就可以了</li>
</ol>

<p><code>SET GLOBAL sql_mode=&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</code></p>

<h2 id="toc_1">注：</h2>

<p>NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零<br/>
NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p>

<p>测试新建表，ok。可以了。</p>

<h2 id="toc_2">终极解决方案</h2>

<p>修改my.ini配置文件直接修改启动sql_mode<br/>
在[mysqld]下添加<br/>
可以设置<code>sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<p>或者为了避免group by限制 直接设置为<code>STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION</code></p>

<pre class="line-numbers"><code class="language-text">[mysqld]
sql_mode=STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION
</code></pre>

<p>dos命令重启mysql</p>

<pre class="line-numbers"><code class="language-dos">net stop mysql
net start mysql
</code></pre>

<p><img src="media/16022150270617/16125316826946.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yum安装提示错误Thread/process failed: Thread died in Berkeley DB librar]]></title>
    <link href="http://565785929.github.io/15914577057463.html"/>
    <updated>2020-06-06T23:35:05+08:00</updated>
    <id>http://565785929.github.io/15914577057463.html</id>
    <content type="html"><![CDATA[
<p>问题描述：#<br/>
yum 安装更新提示 rpmdb: Thread/process failed: Thread died in Berkeley DB library</p>

<p>问题解决：#<br/>
01、删除yum临时库文件</p>

<p><code>rm -fr /var/lib/rpm/__db.*</code></p>

<p>02、重建rpm数据库</p>

<p><code>rpm --rebuilddb</code></p>

<p>03、清理缓存及生产yumdb缓存</p>

<p><code>yum clean all</code><br/>
<code>yum makecache</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[离线支付方案]]></title>
    <link href="http://565785929.github.io/15873033963371.html"/>
    <updated>2020-04-19T21:36:36+08:00</updated>
    <id>http://565785929.github.io/15873033963371.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">二维码登陆+2FA双因素认证</h1>

<p>二者都是很常用的技术，但是两者相结合遍可以用于二维码离线支付。</p>

<h2 id="toc_1">密码安全</h2>

<p>首先讨论一下如何让密码安全？<br/>
注册时密码数据流，密码首先在web或客户端由用户手动输入，然后经过网络传输至服务端，服务端入库。<br/>
登陆时密码数据流，密码也是在web或客户端由用户手动输入，然后经过网络传输至服务端，服务端查库。</p>

<p>所以我们可以在客户端、网络传输、数据库中分别采用下图方案保护我们的密码。</p>

<p><img src="media/15868546287595/15868573710308.jpg" alt="" style="width:1403px;"/></p>

<h2 id="toc_2">二维码登陆原理</h2>

<p>登录做两件事<br/>
1、告诉系统我是谁;<br/>
2、向系统证明我是谁;</p>

<p>二维码其实是字符串的图片表现形式</p>

<p><strong>基于token的认证机制</strong><br/>
1、首次登录客户端向服务器传送密码+设备信息进行认证;<br/>
2、服务端认证通过后,生成token与设备信息进行对应,并存储在服务端并将token回传到客户端;<br/>
3、客户端每次访问API时,需要携带token+设备信息作为验证信息;<br/>
4、服务端验证token+设备信息是否对应,验证通过后,返回API响应,验证不通过,拒绝服务;<br/>
特别注意:token是某个客户端私有的,即使有token,没有对应的设备信息,也是验证不通过的</p>

<h2 id="toc_3">双因素认证（2FA）</h2>

<p>一般情况下，网站登录都使用账号密码的方式登录，这是最常见的认证方法，但是不安全，容易泄露和冒充。</p>

<h3 id="toc_4">双因素认证概念：</h3>

<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>

<ul>
<li>秘密信息：只有该用户知道、其他人不知道的某种信息，比如密码</li>
<li>个人物品：该用户的私人物品，比如身份证、钥匙、手机号</li>
<li>生物特征：该用户的遗传特征，比如指纹、相貌、虹膜等</li>
</ul>

<p>这些证据就称为三种”因素“。因素越多，证明力就越强，身份就越可靠。</p>

<p>双因素认证就是指，通过认证同事需要两个因素的证据。</p>

<p>银行卡取钱就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>

<h3 id="toc_5">双因素认证方案</h3>

<p>常用的双因素组合是密码 + 某种个人物品，比如网上银行的 U 盾。用户插上 U 盾，再输入密码，才能登录网上银行。</p>

<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案。</p>

<p>国内的很多网站要求，用户输入密码时，还要提供短消息发送的验证码，以证明用户确实拥有该手机。</p>

<p>但是，短消息是不安全的，容易被拦截和伪造，SIM 卡也可以克隆。已经有案例，先伪造身份证，再申请一模一样的手机号码，把钱转走。</p>

<p>因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 TOTP。</p>

<h3 id="toc_6">TOTP的概念</h3>

<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238">RFC6238</a>。</p>

<p>它的步骤如下。</p>

<p>第一步，用户开启双因素认证后，服务器生成一个密钥。</p>

<p>第二步：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。<br/>
<img src="media/15847222662823/15847227437312.jpg" alt=""/><br/>
注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>

<p>第三步，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。<br/>
<img src="media/15847222662823/15847227654261.jpg" alt=""/><br/>
第四步，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>

<h3 id="toc_7">TOTP算法</h3>

<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>

<p>答案就是下面的公式。</p>

<p>TC = floor((unixtime(now) − unixtime(T0)) / TS)</p>

<p>上面的公式中，TC 表示一个时间计数器，unixtime(now)是当前 Unix 时间戳，unixtime(T0)是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>

<p>TC = floor(unixtime(now) / 30)<br/>
所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>

<p>接下来，就可以算出哈希了。</p>

<p>TOTP = HASH(SecretKey, TC)<br/>
上面代码中，HASH就是约定的哈希函数，默认是 SHA-1。</p>

<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>

<h3 id="toc_8">总结</h3>

<p>双因素认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对双因素认证无效。</p>

<p>缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>

<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>

<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</p>

<h2 id="toc_9">二维码在线支付</h2>

<p>首先谈一下在线支付方案。<br/>
首先这个二维码其实只是用户的唯一标识。让商户端扫描之后，知道是谁要付款。</p>

<p>所以简单实现，一般为客户端请求服务端，服务端在redis中存储客户信息，一分钟失效。<br/>
然后商户端扫描redis中存储的这个uuid，通过这个uuid获取到客户的信息后，开始下订单，扣款。</p>

<p><img src="media/15873033963371/15873054303125.jpg" alt="" style="width:576px;"/></p>

<h2 id="toc_10">二维码离线支付</h2>

<p>上文的方法有个弊端就是，如果客户端没有网络，就无法请求服务端生成二维码并支付了。这严重影响了用户的体验。</p>

<p>如果客户端可以自己生成uuid就好了。</p>

<ol>
<li>服务器生成token，通过加密方式（如https）传递到客户端。</li>
<li>打开付款码时，本地生成一段含有token和当前时间时间戳的哈希值，如sha1(token+UnixTimestamp),转换为byte[]并截取指定长度后转换为int变量otp。</li>
<li>设置支付用户账号（手机号）为int变量id。</li>
<li>设otp在[0, n]中，通过code=id*n+otp，即可将OTP和ID合并在同一个数字里，成为最终的二维码，并每隔指定时间更新一次。</li>
<li>通过商家扫码枪扫描，服务器获取了code，通过(int)(code/n)得到id，通过code%n得到otp。</li>
<li>通过id找到token，通过token和当前时间验证otp。</li>
<li>验证通过即可下单。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双因素认证（2FA）]]></title>
    <link href="http://565785929.github.io/15847222662823.html"/>
    <updated>2020-03-21T00:37:46+08:00</updated>
    <id>http://565785929.github.io/15847222662823.html</id>
    <content type="html"><![CDATA[
<p>一般情况下，网站登录都使用账号密码的方式登录，这是最常见的认证方法，但是不安全，容易泄露和冒充。</p>

<h2 id="toc_0">双因素认证概念：</h2>

<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>

<ul>
<li>秘密信息：只有该用户知道、其他人不知道的某种信息，比如密码</li>
<li>个人物品：该用户的私人物品，比如身份证、钥匙、手机号</li>
<li>生物特征：该用户的遗传特征，比如指纹、相貌、虹膜等</li>
</ul>

<p>这些证据就称为三种”因素“。因素越多，证明力就越强，身份就越可靠。</p>

<p>双因素认证就是指，通过认证同事需要两个因素的证据。</p>

<p>银行卡取钱就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>

<h2 id="toc_1">双因素认证方案</h2>

<p>常用的双因素组合是密码 + 某种个人物品，比如网上银行的 U 盾。用户插上 U 盾，再输入密码，才能登录网上银行。</p>

<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案。</p>

<p>国内的很多网站要求，用户输入密码时，还要提供短消息发送的验证码，以证明用户确实拥有该手机。</p>

<p>但是，短消息是不安全的，容易被拦截和伪造，SIM 卡也可以克隆。已经有案例，先伪造身份证，再申请一模一样的手机号码，把钱转走。</p>

<p>因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 TOTP。</p>

<h2 id="toc_2">TOTP的概念</h2>

<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238">RFC6238</a>。</p>

<p>它的步骤如下。</p>

<p>第一步，用户开启双因素认证后，服务器生成一个密钥。</p>

<p>第二步：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。<br/>
<img src="media/15847222662823/15847227437312.jpg" alt=""/><br/>
注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>

<p>第三步，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。<br/>
<img src="media/15847222662823/15847227654261.jpg" alt=""/><br/>
第四步，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>

<h2 id="toc_3">TOTP算法</h2>

<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>

<p>答案就是下面的公式。</p>

<p>TC = floor((unixtime(now) − unixtime(T0)) / TS)</p>

<p>上面的公式中，TC 表示一个时间计数器，unixtime(now)是当前 Unix 时间戳，unixtime(T0)是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>

<p>TC = floor(unixtime(now) / 30)<br/>
所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>

<p>接下来，就可以算出哈希了。</p>

<p>TOTP = HASH(SecretKey, TC)<br/>
上面代码中，HASH就是约定的哈希函数，默认是 SHA-1。</p>

<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>

<h2 id="toc_4">总结</h2>

<p>双因素认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对双因素认证无效。</p>

<p>缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>

<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>

<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux]]></title>
    <link href="http://565785929.github.io/15833368444152.html"/>
    <updated>2020-03-04T23:47:24+08:00</updated>
    <id>http://565785929.github.io/15833368444152.html</id>
    <content type="html"><![CDATA[
<p>Linux下的程序往往使你更加有效率，因为他们可以更高效的使用电脑的资源</p>

<p><strong>不同的Linux发行版之间的主要区别：</strong></p>

<p>1、安装方法不一样，有的复杂，有的简单。</p>

<p>2、安装应用程序的方式不一样。</p>

<p>3、预装的应用程序不一样。</p>

<h3 id="toc_0">linux发行版</h3>

<p>1、RedHat：性能稳定，老牌的linux发行版。收费的是RedHat Enterprise Linux（RHEL。redhat企业版）。目前RedHat分为两个系列：由RedHat公司提供收费技术支持。以及社区开发的免费的Fedora。</p>

<p>2、Fedora：RedHat的社区免费后继版，非常强大。</p>

<p>3、CentOS：国内许多企业选择CentOS，CentOS可以算是RHEL的克隆版，最大的好处就是免费。</p>

<p>4、SUSE：德国最著名的Linux发行版。</p>

<p>5、Debian：算是迄今为止，最遵循GNU规范的linux系统。（gnu的目标就是创建一套完全自由的操作系统。）</p>

<p>6、Ubuntu：Debian的后继一个分支。也是课程使用的linux发行版。</p>

<h3 id="toc_1">Ubuntu的优点</h3>

<p>1、简便易用。对于初学者，Ubuntu系统算是非常简单的，除了命令。</p>

<p>2、更新定期而频繁。每6个月就有一个新的Ubuntu版本，使用者非常多，支持的社区也很多。</p>

<p>3、标准化。</p>

<h3 id="toc_2">系统设置</h3>

<p><strong>lshw</strong>    获取硬件信息</p>

<p><strong>lscpu</strong>   获取CPU信息</p>

<p><strong>lsusb</strong>   获取usb接口信息</p>

<p><strong>uname</strong>   获取系统相关信息</p>

<p><strong>df</strong>  ：查看磁盘空间</p>

<p><strong>date</strong>    ：查看日期和时间</p>

<blockquote>
<p>&quot;+%j&quot; 今年中的第几天</p>
</blockquote>

<p><strong>hostname</strong>    ：显示主机名</p>

<p><strong>ifconfig</strong>    ：显示网络接口参数</p>

<h3 id="toc_3">关机重启命令</h3>

<p><strong>reboot</strong>  ：重启系统</p>

<p><strong>poweroff</strong>：   关机</p>

<p><strong>shutdown</strong>：   是定时关机</p>

<blockquote>
<p>shutdown -h time  指定时间，不写，就是一分钟之后执行</p>

<p>shutdown -h +5    ：五分钟后关机</p>

<p>shutdown -c   ：取消定时关机</p>

<p>shutdown -r now   ：立即重启</p>
</blockquote>

<h3 id="toc_4">常用指令</h3>

<pre class="line-numbers"><code class="language-python">#通过上下方向键来获取过往执行过的linux命令
#命令仅需输入前几位就可以用TAB键补全
要想准确，高效地完成各种任务，仅依赖命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数：
linux命令格式：
命令名称  [命令参数] [命令对象]
#命令名称、参数、对象之间用空格键分隔。

命令参数分为：
长格式  man --help
短格式  man -h

</code></pre>

<h3 id="toc_5">man 命令中常用按键以及用途</h3>

<table>
<thead>
<tr>
<th>按键</th>
<th>用处</th>
</tr>
</thead>

<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home（fn+左方向键）</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end（fn+右方向键）</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上至下搜索某个关键词，如 ‘/and’</td>
</tr>
<tr>
<td>?</td>
<td>从下至上搜索某个关键词，如 ‘？and’</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">目录命令</h3>

<p>1、pwd   ---print working directory</p>

<p>显示用户当前所处的工作目录</p>

<p>2、cd  ---change directory</p>

<p>用于切换工作路径</p>

<blockquote>
<p>cd 目录名  ：进入某一目录</p>

<p>cd ..    ：返回上一级目录，并显示路径</p>

<p>cd -   ：返回上一次所处的目录</p>

<p>cd ~     ：切换到当前用户的家目录</p>
</blockquote>

<p>3、ls ----list</p>

<p>ls会列举出当前工作目录的内容（文件或文件夹）</p>

<blockquote>
<p>-a    :查看所有文件（包括隐藏文件）</p>

<p>-l    ：查看文件的属性，大小等详细信息</p>
</blockquote>

<pre class="line-numbers"><code class="language-python">第一列一共十位：
#第一位是类型：
d代表目录
-代表是文件
l代表连接

#第二位到十位是权限
权限共九位，分三组，每三个一组
-rwx：
-r read 可读权限  4 或者 0
-w write 可写权限  2 或者 0  如果一条线，一个减号代表0
-x execute 可执行权限  1或者0

这三个字母能表示多少值:0-7
0：什么权限都没有
1：文件只能执行
2：文件只有写权限
3：文件可写可执行
4：文件只有读权限
5：可读可执行
6：可读可写
7：可读可写可执行

#对于文件而言：
可读权限表示允许读其内容，而禁止对其做任何的更改操作
可写权限表示可以改写编辑文件的内容或删除文件。（要有文件所在目录的写权限）
可执行权限表示允许将该文件作为一个程序执行。
#对于目录而言：
可读权限表示允许显示该目录中的内容
可写权限表示可以在目录中新建，删除，重名令文件
可执行权限表示可以进入该目录。可执行权限是基本权限。

权限共九位，每三个一组
1、代表当前用户的权限  ---读写和执行
2、代表当前用户所属的组的权限
3、代表其他组的权限

-w-


</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 开启自动驼峰转换]]></title>
    <link href="http://565785929.github.io/15826152154212.html"/>
    <updated>2020-02-25T15:20:15+08:00</updated>
    <id>http://565785929.github.io/15826152154212.html</id>
    <content type="html"><![CDATA[
<p>在mybatis-config.xml文件中加入此设置</p>
<?xml version="1.0" encoding="UTF-8" ?>
<p>&lt;!DOCTYPE configuration<br/><br/>
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br/><br/>
&quot;<a href="http://mybatis.org/dtd/mybatis-3-config.dtd%22%3E">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a><br/><br/>
<configuration><br/><br/>
    <settings><br/><br/>
        <setting name="mapUnderscoreToCamelCase" value="true" /><br/><br/>
    </settings><br/><br/>
</configuration></p>

<p><img src="media/15826152154212/15826153307445.jpg" alt=""/></p>

<p>参考:<br/>
<a href="https://yq.aliyun.com/articles/662319">https://yq.aliyun.com/articles/662319</a><br/>
<a href="https://www.cnblogs.com/pjfmeng/p/7677773.html">https://www.cnblogs.com/pjfmeng/p/7677773.html</a><br/>
<a href="https://www.cnblogs.com/zhouricong/p/9483099.html">https://www.cnblogs.com/zhouricong/p/9483099.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java和mysql转换]]></title>
    <link href="http://565785929.github.io/15823891714442.html"/>
    <updated>2020-02-23T00:32:51+08:00</updated>
    <id>http://565785929.github.io/15823891714442.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th>java类</th>
<th> </th>
<th>mysql数据库</th>
</tr>
</thead>

<tbody>
<tr>
<td>java.lang.Byte</td>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>integer</td>
<td>INGEGER</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>float</td>
<td>FLOAT</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>double</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>java.lang.BigDecimal</td>
<td>big_decimal</td>
<td>NUMERIC</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>string</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>yes_no</td>
<td>CHAR(1)(&#39;Y&#39;或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>true_false</td>
<td>CHAR(1)(‘Y’或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.uitl.Date</td>
<td>java.sql.Date</td>
<td>date</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>celendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>calendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.io.Serializable</td>
<td>serializable</td>
<td>VARBINARY/BLOB</td>
</tr>
<tr>
<td>java.sql.Clob</td>
<td>clob</td>
<td>CLOB</td>
</tr>
<tr>
<td>java.sql.Blob</td>
<td>blob</td>
<td>BLOB</td>
</tr>
<tr>
<td>java.lang.Class</td>
<td>class</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Locale</td>
<td>locale</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.TimeZone</td>
<td>timezone</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Currency</td>
<td>currency</td>
<td>VARCHAR</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 查看表注释或字段注释]]></title>
    <link href="http://565785929.github.io/15823882245344.html"/>
    <updated>2020-02-23T00:17:04+08:00</updated>
    <id>http://565785929.github.io/15823882245344.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">查看注释</h2>

<p>查看所有表的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
table_name 表名,
table_comment 表说明
FROM
information_schema.TABLES
WHERE
table_schema = &#39;数据库名&#39;
ORDER BY
table_name
</code></pre>

<p>查询所有表及字段的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
a.table_name 表名,
a.table_comment 表说明,
b.COLUMN_NAME 字段名,
b.column_comment 字段说明,
b.column_type 字段类型,
b.column_key 约束
FROM
information_schema.TABLES a
LEFT JOIN information_schema.COLUMNS b ON a.table_name = b.TABLE_NAME
WHERE
a.table_schema = &#39;数据库名&#39;
ORDER BY
a.table_name
</code></pre>

<p>查询某表的所有字段的注释</p>

<pre class="line-numbers"><code class="language-sql">select 
COLUMN_NAME 字段名,
column_comment 字段说明,
column_type 字段类型,
column_key 约束 from information_schema.columns 
where table_schema = &#39;数据库名&#39;
and table_name = &#39;表名&#39; ; 
</code></pre>

<p>或者</p>

<pre class="line-numbers"><code class="language-sql">show full columns from 表名;
</code></pre>

<h2 id="toc_1">查看表生成的DDL</h2>

<p><strong>注意表名不加单引号</strong></p>

<pre class="line-numbers"><code class="language-sql">show create table 表名;
</code></pre>

<h2 id="toc_2">新建表以及添加表和字段的注释</h2>

<pre class="line-numbers"><code class="language-sql">create table t_user(
    ID INT(19) primary key auto_increment  comment &#39;主键&#39;,
    NAME VARCHAR(300) comment &#39;姓名&#39;,
    CREATE_TIME date comment &#39;创建时间&#39;
)comment  = &#39;用户信息表&#39;;
</code></pre>

<h2 id="toc_3">修改表/字段的注释</h2>

<p>修改表注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user comment  = &#39;修改后的表注释信息(用户信息表)&#39;;
</code></pre>

<p>修改字段注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user modify column id int comment &#39;主键ID&#39;;
</code></pre>

<p>参考：简书<a href="https://www.jianshu.com/p/e6286174d35c">Mysql 查看表注释或字段注释</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易云 最嗨电音 爬虫]]></title>
    <link href="http://565785929.github.io/15819525546014.html"/>
    <updated>2020-02-17T23:15:54+08:00</updated>
    <id>http://565785929.github.io/15819525546014.html</id>
    <content type="html"><![CDATA[
<p>抓手机包找到音乐链接 Size最大</p>

<p><img src="media/15819525546014/15819533512601.jpg" alt="" style="width:1062px;"/></p>

<p>贴到浏览器发现可以打开，确实为此音乐</p>

<p><img src="media/15819525546014/15819534156184.jpg" alt="" style="width:546px;"/></p>

<p>筛选所有音乐链接 <code>m\d.music.126.net</code><br/>
<img src="media/15819525546014/15819537374098.jpg" alt="" style="width:1152px;"/></p>

<p>积攒一段时间，将这些链接拷贝到文件里<br/>
<img src="media/15819525546014/15819535577751.jpg" alt="" style="width:973px;"/></p>

<p>编写Python代码，统一下载</p>

<pre class="line-numbers"><code class="language-python">import requests
from urllib import request


class Electronic:

    def __init__(self) -&gt; None:
        self.s = requests.session()
        self.dir = &quot;music/&quot;
        self.file = &quot;music.txt&quot;

    def open_file(self):
        with open(self.file, &#39;r&#39;) as f:
            for number, line in enumerate(f, start=1):
                yield line

    def get_music(self, url, name):
        try:
            self.s.get(url)
            request.urlretrieve(url, name)
        except Exception as ex:
            print(url, ex)

    def start(self):
        for url in self.open_file():
            print(url)
            name = url.split(&#39;/&#39;)[-1].strip()
            self.get_music(url, self.dir + name)


if __name__ == &#39;__main__&#39;:

    e = Electronic()
    e.start()

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cheat.sh]]></title>
    <link href="http://565785929.github.io/15802234606202.html"/>
    <updated>2020-01-28T22:57:40+08:00</updated>
    <id>http://565785929.github.io/15802234606202.html</id>
    <content type="html"><![CDATA[
<p>cheat是在GNU通用公共许可证下，为Linux命令行用户发行的交互式备忘单应用程序。简单来说，它没有提供其他额外多余的信息，只通过使用实例告诉你一个命令参数如何使用。</p>

<h2 id="toc_0">使用</h2>

<p>它无需安装，提供网络查询方式，要从命令行获取UNIX / Linux命令的备忘单，请使用curl或任何其他在查询中指定命令名称的HTTP / HTTPS客户端来查询服务：</p>

<pre class="line-numbers"><code class="language-bash">    curl cheat.sh/tar
    curl cht.sh/curl
    curl https://cheat.sh/rsync
    curl https://cht.sh/tr
</code></pre>

<h2 id="toc_1">安装</h2>

<p>想离线使用，也可以安装客户端，非常简单<br/>
To install the client:</p>

<pre class="line-numbers"><code class="language-bash">    mkdir -p ~/bin/
    curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
    chmod +x ~/bin/cht.sh
</code></pre>

<p>or to install it globally (for all users):</p>

<pre class="line-numbers"><code class="language-bash">    curl https://cht.sh/:cht.sh | sudo tee /usr/local/bin/cht.sh
    sudo chmod +x /usr/local/bin/cht.sh
</code></pre>

<p>之后也可以给cht.sh创建一个别名</p>

<p>client: <code>vi ~/.bashrc</code><br/>
globally: <code>sudo vi /etc/profile</code></p>

<p>在最后添加</p>

<pre class="line-numbers"><code class="language-text"># cheat
alias cht=cht.sh
</code></pre>

<p>重新加载一下配置文件<br/>
client: <code>source ~/.bashrc</code><br/>
globally: <code>source /etc/profile</code></p>

<p>之后可以使用cht获取命令示例<br/>
<img src="media/15802234606202/15802244400106.jpg" alt="" style="width:682px;"/></p>

<p>如果输出的不是你需要的答案，你可以选择带入参数， 例如/1, /2 :</p>

<pre class="line-numbers"><code class="language-text">    curl cht.sh/python/random+string
    curl cht.sh/python/random+string/1
    curl cht.sh/python/random+string/2
</code></pre>

<p><a href="https://github.com/chubin/cheat.sh">github</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crontab 定时任务]]></title>
    <link href="http://565785929.github.io/15776732342055.html"/>
    <updated>2019-12-30T10:33:54+08:00</updated>
    <id>http://565785929.github.io/15776732342055.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Linux</h3>

<p><img src="media/15776732342055/15776733247221.jpg" alt="" style="width:634px;"/></p>

<p>crontab -e <br/>
打开编辑表达式</p>

<p>表达式必须使用绝对路径</p>

<p>sudo systemctl restart crond.service<br/>
重启生效</p>

<p>crontab -l<br/>
查看所有定时任务表达式</p>

<h3 id="toc_1">cht</h3>

<p><img src="media/15776732342055/15826461147316.jpg" alt="" style="width:767px;"/></p>

<pre class="line-numbers"><code class="language-bash">&gt; cht crontab
# crontab
# Schedule cron jobs to run on a time interval for the current user.
# Job definition format: &quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;.

# Edit the crontab file for the current user:
crontab -e

# Edit the crontab file for a specific user:
sudo crontab -e -u user

# View a list of existing cron jobs for current user:
crontab -l

# Remove all cron jobs for the current user:
crontab -r

# Sample job which runs at 10:00 every day (* means any value):
0 10 * * * command_to_execute

# Sample job which runs every minute on the 3rd of April:
* * 3 Apr * command_to_execute

# Sample job which runs a certain script at 02:30 every Friday:
30 2 * * Fri /absolute/path/to/script.sh
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监控Python 运行]]></title>
    <link href="http://565785929.github.io/15773499726644.html"/>
    <updated>2019-12-26T16:46:12+08:00</updated>
    <id>http://565785929.github.io/15773499726644.html</id>
    <content type="html"><![CDATA[
<p>使用memory_profiler模块</p>

<p>memory_profiler模块用来基于逐行测量代码的内存使用。使用这个模块会让代码运行的更慢。</p>

<p>安装方法如下：<br/>
<code>pip install memory_profiler</code></p>

<p>另外，建议安装psutil包，这样memory_profile会运行的快一点：<br/>
<code>pip install psutil</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh]]></title>
    <link href="http://565785929.github.io/15769921068601.html"/>
    <updated>2019-12-22T13:21:46+08:00</updated>
    <id>http://565785929.github.io/15769921068601.html</id>
    <content type="html"><![CDATA[
<p>systemctl stop sshd.service <br/>
停止转发</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh<br/>
关闭80端口程序</p>

<p>pscp -r -l root -pw 5657 e:\htk 118.24.163.26:/root<br/>
e:\htk -&gt; /root 传送文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pscp]]></title>
    <link href="http://565785929.github.io/15769920752565.html"/>
    <updated>2019-12-22T13:21:15+08:00</updated>
    <id>http://565785929.github.io/15769920752565.html</id>
    <content type="html"><![CDATA[
<p>远程传输命令 </p>

<p>pscp和scp功能相同，但pscp同时支持windows下使用，它有效解 决了windows系统向linux服务器传输文件，而且它只有一个文件，即pscp.exe，建议将该文件放到C:\WINDOWS\system32 下面，这样就可以在任何地方调用该文件命令，你也可以放在任意你指定文件夹下。</p>

<p><img src="media/15769920752565/15802251740483.jpg" alt="" style="width:682px;"/></p>

<ol>
<li>环境变量改好后，在命令行下输入 pscp就可以拷文件了：</li>
</ol>

<p>命令格式：pscp localfile rootuser@remoteip:/fileDirectory</p>

<p>拷贝整个文件夹： pscp -r localDir rootuser@remoteip:/fileDirectory</p>

<p>如果是从linux拷贝文件，是同样的方法，只不过是把前后地址对换一下即可;</p>

<ol>
<li>比如我想把windows下e:\htk 整个目录的所有文件复制到linux /root目录下，命令如下：</li>
</ol>

<p><strong>pscp -r -l root -pw 1234567890 e:\htk 192.168.0.204:/root</strong></p>

<p>说明：</p>

<p>-r 复制目录下所有文件;</p>

<p>-l 对方机器(linux)的用户名(root);</p>

<p>-pw 密码(1234567890 );</p>

<p>e:\htk 源文件/文件夹的地址;</p>

<p>192.168.0.204:/root 目的文件/文件夹的地址。192.168.0.204为linux机器的ip地址。</p>

<ol>
<li>反过来，把linux soundRcg目录下的test.txt文件传输到windows e:\下，同样在windows命令行中敲入命令： </li>
</ol>

<p>*<em>pscp -l root -pw 1234567890 192.168.0.204:/soundRcg/test.txt E:*</em></p>

<p>备注：pscp似乎传输速度不是很快。</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git基本使用]]></title>
    <link href="http://565785929.github.io/15769919595310.html"/>
    <updated>2019-12-22T13:19:19+08:00</updated>
    <id>http://565785929.github.io/15769919595310.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Git是分布式版本控制系统 自报家门</h3>

<pre class="line-numbers"><code class="language-text">git config --global user.name &quot;Sajor&quot;
git config --global user.email &quot;565785929@qq.com&quot;
</code></pre>

<h2 id="toc_1">一</h2>

<p>初始化一个Git仓库，使用git init命令。</p>

<p>添加文件到Git仓库，分两步：</p>

<p>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</p>

<p>第二步，使用命令git commit，完成。</p>

<h3 id="toc_2">windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</h3>

<pre class="line-numbers"><code class="language-text">    rm -rf .git  // 删除.git  
    git config --global core.autocrlf false  //禁用自动转换    
    
    git init    // 重新执行
    git add .  
</code></pre>

<h3 id="toc_3">文件添加到仓库 add</h3>

<pre class="line-numbers"><code class="language-text">    git add readme.txt     // filename = readme.txt
</code></pre>

<h3 id="toc_4">用命令 git commit 告诉Git 文件提交到仓库</h3>

<pre class="line-numbers"><code class="language-text">    git commit -m &quot;wrote a readme file&quot; 
    -m后面输入的是本次提交的说明
    commit可以一次提交很多文件，所以你可以多次add不同的文件
</code></pre>

<h2 id="toc_5">二</h2>

<p>要随时掌握工作区的状态，使用git status命令。</p>

<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>

<h3 id="toc_6">git status 查看当前状态</h3>

<pre class="line-numbers"><code class="language-text">    git status 
</code></pre>

<h3 id="toc_7">git diff 查看做了哪些修改</h3>

<pre class="line-numbers"><code class="language-text">    git diff readme.txt    // filename = readme.txt
    git diff    #是工作区(work dict)和暂存区(stage)的比较
    git diff --cached    #是暂存区(stage)和分支(master)的比较（add之后）
</code></pre>

<h2 id="toc_8">三</h2>

<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>

<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>

<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<h3 id="toc_9">git log 显示从最近到最远的提交日志</h3>

<pre class="line-numbers"><code class="language-text">    git log 
    // --pretty=oneline参数 可以在一行显示
    git log --pretty=oneline 
    前面的是commit id（版本号）
</code></pre>

<h3 id="toc_10">回退版本</h3>

<pre class="line-numbers"><code class="language-text">    git reset -- hard HEAD^  
    // 上一个版本是HEAD^ , 上上一个版本就是HEAD^^, 往上100个是HEAD~100
</code></pre>

<h3 id="toc_11">再返回未来的版本可以用commit id 返回</h3>

<pre class="line-numbers"><code class="language-text">    git reset --hard 3628164  // commit id = 3628164
</code></pre>

<h3 id="toc_12">git reflog 记录你的每一次命令</h3>

<pre class="line-numbers"><code class="language-text">    git reflog  前面会加你的commit id
</code></pre>

<hr/>

<h2 id="toc_13">四</h2>

<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</p>

<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>

<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>

<p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>

<h3 id="toc_14">撤销工作区的修改</h3>

<pre class="line-numbers"><code class="language-text">    git checkout -- readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_15">撤销缓存区的提交</h3>

<pre class="line-numbers"><code class="language-text">    git reset HEAD readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_16">工作区删除</h3>

<pre class="line-numbers"><code class="language-text">    rm test.txt
</code></pre>

<h3 id="toc_17">从版本库中删除该文件 git rm 删掉 并提交</h3>

<pre class="line-numbers"><code class="language-text">    git rm test.txt    // filename = test.txt
    git commit -m &quot;remove test.txt&quot;
</code></pre>

<h3 id="toc_18">也可以使用 git checkout 恢复</h3>

<pre class="line-numbers"><code class="language-text">    git checkout -- test.txt
</code></pre>

<h2 id="toc_19">五</h2>

<p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>

<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>

<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>

<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>

<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br/>
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>

<h3 id="toc_20">在GitHub 添加ssh秘钥</h3>

<pre class="line-numbers"><code class="language-text">    ssh-keygen -t rsa    生成ssh秘钥 
    cat C://Users/zzx/.ssh/id_rsa.pub   默认位置
</code></pre>

<h3 id="toc_21">推送到远程仓库</h3>

<pre class="line-numbers"><code class="language-text">    git remote add origin git@github.com:565785929/learngit.git
    git push -u origin master
</code></pre>

<h3 id="toc_22">本地做了提交再更新远程仓库</h3>

<pre class="line-numbers"><code class="language-text">    git push origin master 
</code></pre>

<h3 id="toc_23">远程库已经准备好了 git clone克隆一个本地库</h3>

<pre class="line-numbers"><code class="language-text">    git clone git@github.com:565785929/gitskills.git     // proname = gitskills
</code></pre>

]]></content>
  </entry>
  
</feed>
