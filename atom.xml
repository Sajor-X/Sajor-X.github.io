<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2022-06-29T23:14:17+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL 索引失效]]></title>
    <link href="http://565785929.github.io/16565146473162.html"/>
    <updated>2022-06-29T22:57:27+08:00</updated>
    <id>http://565785929.github.io/16565146473162.html</id>
    <content type="html"><![CDATA[
<p>今天碰到一个MySQL索引失效的问题，想当年面试，面试官问我有没有遇到过索引失效的场景时，我羞涩的答了一个“没有”，甚是尴尬。如今也遇到了MySQL优化器判断失误的时候，特此记录下来，以备下次面试时吊打面试官。</p>

<h3 id="toc_0">记录问题</h3>

<p>tb_order 表有索引</p>

<p><img src="media/16565146473162/16565151968668.jpg" alt="" style="width:866px;"/></p>

<p>搜索时条件也没有违反索引规则，显示可以使用索引，但却没有实际使用。</p>

<p><img src="media/16565146473162/16565152326655.jpg" alt="" style="width:1415px;"/></p>

<p>强制使用 idx_contract_time 索引，发现是可以提高查询速度的。</p>

<p><img src="media/16565146473162/16565154167622.jpg" alt="" style="width:1439px;"/></p>

<h3 id="toc_1">查询资料</h3>

<p>即使存在辅助索引idx_contract_time, 优化器最后可能还是选择primary聚集索引。</p>

<p>原因是：用户选取的数据是需要整行信息，而idx_contract_time索引不能覆盖到我们要查询的信息，因此在对idx_contract_time索引查询到指定数据后，还要再进行一次回表访问来查找整行的信息。</p>

<p>虽然idx_contract_time索引中数据是顺序存放的，但是再进行一次书签查找的数据则是无序的，变成了磁盘上的离散读操作。如果访问的数据量很小，那优化器还是会选择辅助索引，但访问的数据占整个表蛮大一部分时(一般20%)，优化器会选择通过聚集索引来查找数据，因为顺序读的操作会远大于离散读。</p>

<p>如果不能使用覆盖索引的情况，优化器只有数据量小的时候才会使用辅助索引。这是由传统的机械硬盘特性决定的。若使用固态硬盘，随机读操作很快，且有足够的自信能确认使用辅助索引可以带来更好的性能，可以使用Force index强制使用某个索引。</p>

<p><a href="https://blog.csdn.net/b1303110335/article/details/119859453">mysql在扫描情况下会选择全表扫描而不是走索引</a>、<a href="https://blog.csdn.net/weixin_39932181/article/details/113557066">mysql优化器选择使用或者不用索引</a></p>

<h3 id="toc_2">其他引起失效原因</h3>

<p><a href="https://juejin.cn/post/6844904015872917517">后端程序员必备：索引失效的十大杂症</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oh My Zsh]]></title>
    <link href="http://565785929.github.io/16561548241153.html"/>
    <updated>2022-06-25T19:00:24+08:00</updated>
    <id>http://565785929.github.io/16561548241153.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装命令</h2>

<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH">zsh</a> 可以提高终端使用体验，是命令行终端必装软件，下面介绍安装方法</p>

<p><strong>Mac</strong></p>

<p>在 mac 上还是建议使用 item 做为命令行终端，先安装 xcode。</p>

<pre class="line-numbers"><code class="language-text"># 如果没有 brew 命令请自行安装 https://brew.sh/
brew install zsh zsh-completions

chsh -s /bin/zsh

# 如果没有 port 命令，需要先安装  https://www.macports.org/install.php
# 安装后需要执行 export PATH=/opt/local/bin:/opt/local/sbin:$PATH

sudo port install zsh zsh-completions
</code></pre>

<p><strong>ubuntu</strong></p>

<pre class="line-numbers"><code class="language-text"># 安装zsh
sudo apt install zsh

# 查看版本号，检测安装是否成功
zsh --version

# 设置默认shell
chsh -s $(which zsh)

# 注销帐号后执行，查看当前shell是否是zsh
echo $SHELL
</code></pre>

<p><strong>centos</strong></p>

<p>安装软件</p>

<pre class="line-numbers"><code class="language-text">sudo yum update &amp;&amp; sudo yum -y install zsh
 
# 设置当前用户默认 shell
  
chsh -s /bin/zsh

# 或
sudo usermod -s $(which zsh) 用户名
 
# 注销帐号后执行，查看当前 shell 是否是 zsh
 
echo $SHELL
</code></pre>

<h2 id="toc_1">oh my zsh</h2>

<p><a href="https://ohmyz.sh/">oh my zsh</a> 是管理 ZSH 的配置，并提供了丰富的插件</p>

<p><img src="media/16561548241153/16561550756772.jpg" alt=""/></p>

<p><strong>软件安装</strong></p>

<p>因为是国外资源可能下载不成功，多试几次</p>

<pre class="line-numbers"><code class="language-text">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>

<p>如果上面的不行，试试下面的命令</p>

<pre class="line-numbers"><code class="language-text">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>

<p>如果还是不能下载，就再试试下面的命令</p>

<pre class="line-numbers"><code class="language-text">sh -c &quot;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&quot;
</code></pre>

<p><strong>初始配置</strong></p>

<p>第一次安装后，需要注销后重新登录。之后会显示如下初始配置界面，选择<code>q</code>退出</p>

<p><img src="media/16561548241153/16561551482665.jpg" alt=""/></p>

<p>主要在配置文件 <code>~/.zshrc</code> 中修改设置。</p>

<blockquote>
<p>有些软件比如 LINUXBREW，的配置荐在<code>~/.profile</code>文件中，安装了 zsh 就需要复制到 `~/.zshrc ｀文件头部</p>
</blockquote>

<h3 id="toc_2">修改主题</h3>

<p>ZSH 拥有<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">丰富的主题</a></p>

<p>修改配置文件 <code>~/.zshrc</code> 中的 <code>ZSH_THEME</code> 来设置使用的风格</p>

<pre class="line-numbers"><code class="language-text">ZSH_THEME=&quot;bira&quot;
</code></pre>

<p>更新配置也可以选择重起终端</p>

<pre class="line-numbers"><code class="language-text">source ~/.zshrc
</code></pre>

<h2 id="toc_3">插件扩展</h2>

<h3 id="toc_4">配置文件</h3>

<ul>
<li><p>插件需要修改 <code>~/.zshrc</code> 配置文件中的 <code>plugins</code>配置段</p></li>
<li><p>在目录 <code>~/.oh-my-zsh/plugins</code>中默认存在了大量插件，只要添加到配置项中即可。</p></li>
<li><p>更新配置后使用<code>source ~/.zshrc</code>命令重新加载配置</p></li>
</ul>

<h3 id="toc_5">历史记录</h3>

<p>这个插件需要单独下载</p>

<pre class="line-numbers"><code class="language-text">git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
</code></pre>

<p>下载后在配置文件的 <code>plugins</code> 选项的最后面添加即可</p>

<pre class="line-numbers"><code class="language-text">plugins=(git history history-substring-search node npm wd web-search last-working-dir vi-mode zsh-autosuggestions)
</code></pre>

<p>有时 <code>zsh-autosuggestions</code> 插件的提示颜色看不清，可以通过修改颜色处理。打开配置文件 <code>~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</code> 修改以下配置项</p>

<pre class="line-numbers"><code class="language-text">typeset -g ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=12&#39;
</code></pre>

<p>重新加载</p>

<pre class="line-numbers"><code class="language-text">source ~/.zshrc
</code></pre>

<h3 id="toc_6">命令提示</h3>

<p>通过安装 <a href="https://mimosa-pudica.net/zsh-incremental.html">incr</a> 插件就可以实现以下命令提示效果</p>

<p><img src="media/16561548241153/zsh.a9a9cc11.gif" alt="zsh.a9a9c"/></p>

<p>首先下载插件<br/>
<code>wget https://mimosa-pudica.net/src/incr-0.2.zsh</code><br/>
加载插件<br/>
<code>source incr*.zsh</code></p>

<h2 id="toc_7">　其他设置</h2>

<h3 id="toc_8">中文乱码</h3>

<p>ITERM2本地中文乱码问题</p>

<p>输入 locale 可以查看字符编码设置情况，而我的对应值是空的。</p>

<p>我在本地和服务器都用 zsh 替代了 bash，而且使用了 oh-my-zsh，而默认的.zshrc 没有设置为 utf-8 编码，所以本地和服务器端都要在.zshrc 设置，步骤如下，bash 对应.bash_profile 或.bashrc 文件。</p>

<p>编辑 <code>~/.zshrc</code> 文件或 <code>/etc/profile</code>文件，在文件内容末端添加：</p>

<pre class="line-numbers"><code class="language-text">export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
</code></pre>

<p>接着加载文件<code>source ~/.zshrc</code>并重启终端。</p>

<p>设置成功的话，在本地和登录到服务器输入 locale 回车会显示下面内容。</p>

<pre class="line-numbers"><code class="language-text">LANG=&quot;en_US.UTF-8&quot;
LC_COLLATE=&quot;en_US.UTF-8&quot;
LC_CTYPE=&quot;en_US.UTF-8&quot;
LC_MESSAGES=&quot;en_US.UTF-8&quot;
LC_MONETARY=&quot;en_US.UTF-8&quot;
LC_NUMERIC=&quot;en_US.UTF-8&quot;
LC_TIME=&quot;en_US.UTF-8&quot;
LC_ALL=&quot;en_US.UTF-8&quot;
</code></pre>

<h3 id="toc_9">默认编辑器</h3>

<p>在 <code>~/.zshrc</code>或<code>~/.bashrc</code>配置文中件添加以下指令。例: <code>export EDITOR=code</code> 是将默认编辑器修改为 vscode  </p>

<p>来源：<a href="https://doc.houdunren.com/soft/4%20zsh.html#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">ZSH软件安装</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mydumper & myloader]]></title>
    <link href="http://565785929.github.io/16559790679652.html"/>
    <updated>2022-06-23T18:11:07+08:00</updated>
    <id>http://565785929.github.io/16559790679652.html</id>
    <content type="html"><![CDATA[
<p><a href="https://launchpad.net/mydumper">mydumper</a> 是一款社区开源的逻辑备份工具。该工具主要由 C 语言编写，目前由 MySQL 、Facebook 等公司人员开发维护。</p>

<p><a href="https://github.com/maxbube/mydumper">GitHub 地址</a></p>

<p>参考官方介绍，mydumper 主要有以下几点特性：</p>

<ul>
<li>支持多线程导出数据，速度更快。</li>
<li>支持一致性备份。</li>
<li>支持将导出文件压缩，节约空间。</li>
<li>支持多线程恢复。</li>
<li>支持以守护进程模式工作，定时快照和连续二进制日志。</li>
<li>支持按照指定大小将备份文件切割。</li>
<li>数据与建表语句分离。</li>
</ul>

<p>可能各个版本备份出来的文件命名稍有不同，从文件命名可以较为明显的看出该文件的内容，大致总结下文件命名规则如下：</p>

<ul>
<li>dbname-schema-create.sql：建库语句。</li>
<li>dbname-schema-post.sql：包含事件、存储过程及函数创建语句（若存在则有该文件）。</li>
<li>dbname.tbname.metadata：记录这个表的行数。</li>
<li>dbname.tbname-schema.sql：此表的创建语句。</li>
<li>dbname.tbname-schema-triggers.sql：创建触发器语句（若该表存在触发器 则有此文件）。</li>
<li>dbname.tbname.sql：该表的插入数据语句（若该表为空 则不存在此文件）。</li>
<li>dbname.viewname-schema.sql：创建视图语句（只列举出视图字段）。</li>
<li>dbname.viewname-schema-view.sql：创建视图的真正语句。</li>
<li>metadata：记录开始及结束备份的时间以及二进制日志位置。</li>
</ul>

<p><strong>mydumper 导出示例</strong></p>

<pre class="line-numbers"><code class="language-text">mydumper -u [user] -h [ip: xxx.xxx.xx.x] -p [password] -B [database] -o [local dir: /tmp/xx] -T [table list: tb_anchor,tb_contract_anchor] 

echo &quot;ending...&quot;
</code></pre>

<p><strong>myloader 导入示例</strong></p>

<pre class="line-numbers"><code class="language-text">myloader -h xxx.xxx.xx.xx -p pass 
myloader -u [user] -h [ip: 47.97.51.185] -p [password] -o -d [local dir: /tmp/jeecg/] -B [database]

echo &quot;finish&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IaaS、PaaS、SaaS的区别]]></title>
    <link href="http://565785929.github.io/16540505085467.html"/>
    <updated>2022-06-01T10:28:28+08:00</updated>
    <id>http://565785929.github.io/16540505085467.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16540505085467/16540689173904.jpg" alt=""/></p>

<p>来源：<a href="https://zhuanlan.zhihu.com/p/276054509">IaaS、PaaS、SaaS的区别</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏感词匹配]]></title>
    <link href="http://565785929.github.io/16533800798764.html"/>
    <updated>2022-05-24T16:14:39+08:00</updated>
    <id>http://565785929.github.io/16533800798764.html</id>
    <content type="html"><![CDATA[
<p><a href="https://blog.csdn.net/weixin_46453301/article/details/105130965">DFA算法和AC自动机算法</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium]]></title>
    <link href="http://565785929.github.io/16533777011588.html"/>
    <updated>2022-05-24T15:35:01+08:00</updated>
    <id>http://565785929.github.io/16533777011588.html</id>
    <content type="html"><![CDATA[
<p>如何防止selenium被检测， 这里有个<a href="https://bot.sannysoft.com/">工具</a></p>

<p>一些相关帖子。</p>

<ul>
<li><a href="https://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver">防止selenium被检测</a></li>
<li><a href="https://blog.csdn.net/weixin_46453301/article/details/110859698?spm=1001.2014.3001.5502">别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征</a></li>
<li><a href="https://blog.csdn.net/weixin_46453301/article/details/110858779?spm=1001.2014.3001.5502">如何正确移除Selenium中的 window.navigator.webdriver</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[protobuf]]></title>
    <link href="http://565785929.github.io/16533196041081.html"/>
    <updated>2022-05-23T23:26:44+08:00</updated>
    <id>http://565785929.github.io/16533196041081.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<p>首先到<a href="https://github.com/protocolbuffers/protobuf/releases">git</a>上下载 protoc 的二进制文件。</p>

<p>然后下载对应语言的代码。例如<a href="https://github.com/protocolbuffers/protobuf/tree/main/python">python</a>：</p>

<pre class="line-numbers"><code class="language-text">$ python setup.py build
$ python setup.py test
$ python setup.py install
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[某音APP广告爬取]]></title>
    <link href="http://565785929.github.io/16520626552663.html"/>
    <updated>2022-05-09T10:17:35+08:00</updated>
    <id>http://565785929.github.io/16520626552663.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">方案一：</h3>

<p>通过修改某音编译好的so库代码，修改判断证书部分函数返回值，达到绕过ssl pinning的目的，然后使用抓包工具抓包。<br/>
优点：不用配置hook框架，修改一次即可覆盖<br/>
缺点：没有核心技术能力，无法主动更新迭代</p>

<ul>
<li><a href="https://bbs.pediy.com/thread-269028.htm">看雪论坛原创17.3</a></li>
<li><a href="https://www.52pojie.cn/thread-1611180-1-1.html">吾爱破解20.0</a></li>
<li><a href="https://www.cnblogs.com/theseventhson/p/15161954.html">网友分析</a></li>
</ul>

<h3 id="toc_1">方案二：</h3>

<p>类似方案一，通过hook框架，动态修改安卓内部代码函数的入参，返回值等信息，达到绕过ssl pinning的目的，然后使用抓包工具。</p>

<p>优点：框架热门资料多，较方案三可拓展性强<br/>
缺点：</p>

<ul>
<li><a href="https://www.jianshu.com/p/56b57ceefcae">简书抖音Frida代码</a></li>
<li><a href="https://bbs.pediy.com/thread-268014.htm">看雪论坛某书hook过程</a></li>
<li><a href="https://blog.51cto.com/u_15101562/2622472?b=totalstatistic">51CTO抖音数据采集Frida教程，Frida Java Hook 详解：代码及示例</a></li>
<li><a href="https://www.its404.com/searchArticle?qc=frida%20hook%20%E6%8A%93%E5%8C%85&amp;page=1">frida教程</a></li>
<li><a href="https://www.codetd.com/article/12727405">抖音数据采集Frida脱壳工具</a></li>
<li><a href="http://zhaoxincheng.com/index.php/2021/07/30/%e7%9f%ad%e8%a7%86%e9%a2%91%e6%9c%80%e6%96%b0%e7%89%88%e9%80%9a%e7%94%a8quic%e5%8d%8f%e8%ae%ae%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88/">快手、抖音短视频最新版抓包</a></li>
</ul>

<h3 id="toc_2">方案三：</h3>

<p>通过安卓测试框架截图，拿到相关数据<br/>
优点：简单，且多平台适用<br/>
缺点：拿不到准确数，不好拓展</p>

<ul>
<li><a href="https://airtest.readthedocs.io/zh_CN/latest/">airtest文档</a></li>
<li><a href="https://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver">防止selenium被检测</a></li>
<li><a href="https://blog.csdn.net/sirobot/article/details/105730906">关于selenium的一些资料</a></li>
</ul>

<h2 id="toc_3">再次尝试</h2>

<h3 id="toc_4">方案一：</h3>

<p>首先采用修改so的方式，由于本人没有吾爱的会员，所以只能下载到看雪上17.3版本的so文件。但是之前装好的安卓5.0搭配 某音17.5 是不需要破解，直接就可以抓包。所以尝试使用新版替换一下，结果发现抖音打不开了。。</p>

<p>由于不懂逆向，看不懂汇编，所以只能安装17.3版本抖音，下载原libsscronet.so文件与论坛大佬提供的做对比。</p>

<pre class="line-numbers"><code class="language-text"># 使用vim对比
vimdiff -bd org_libsscronet.so gai_libsscronet.so

# 切换窗口
ctrl+w 

# 二进制转十六进制查看
:%! xxd

# 下一处不同
[c
# 上一处不同
]c
</code></pre>

<p>可是只发现了两处不同，和论坛大佬提到的四处对应不上。但是也没有头绪，只能留下没有技术的眼泪。</p>

<p><img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-164224.png" alt="飞书20220512-164224"/></p>

<p>之后使用<code>IDA PRO</code>工具打开两个so文件，根据<code>vim</code> 提示的地址 <code>001ccbb0</code> 在<code>IDA PRO</code>中按快捷键 <code>g</code> 跳转。</p>

<p><img src="media/16520626552663/16523453793823.jpg" alt=""/></p>

<p>然后对比两个文件的不同。</p>

<p><img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-171018.png" alt="飞书20220512-171018"/><br/>
<img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-171016.png" alt="飞书20220512-171016"/></p>

<p>发现在 <code>MOVS  R0, #1</code> 这里有不同。然后记录一下周边函数名称<code>HandleVerifyResult &amp; VerifyCert</code></p>

<p>于是下载某音APP20.5最新版，如法炮制。将1改为0，然后 apply patchs并将该文件放入原来位置，修改一下用户组和权限，重启虚拟机即可。</p>

<h2 id="toc_5">替换so文件</h2>

<p>联想模拟器：adb connect 127.0.0.1:11509<br/>
mumu模拟器：adb connect 127.0.0.1:7555</p>

<pre class="line-numbers"><code class="language-text">adb connect 127.0.0.1:11509
adb push ./libsscronet20.7.so /data/app/com.ss.android.ugc.aweme-1/lib/arm

adb shell 
rm -rf /data/app/com.ss.android.ugc.aweme-1/lib/arm/libsscronet.so

mv /data/app/com.ss.android.ugc.aweme-1/lib/arm/libsscronet20.7.so /data/app/com.ss.android.ugc.aweme-1/lib/arm/libsscronet.so 

chmod 777 /data/app/com.ss.android.ugc.aweme-1/lib/arm/libsscronet.so 
</code></pre>

<h2 id="toc_6">protobuf</h2>

<p>抓到包之后发现里面文字显示都不正常，通过请求头发现，原来使用的谷歌的protobuf协议，类似json和xml用于两端数据传输，因为protobuf更节省空间，传输过程中将变量名省略，变量名都以文件的方式存储在服务器和客户端上，我们可以使用Python的<br/>
blackboxprotobuf库来解析。</p>

<pre class="line-numbers"><code class="language-python">import blackboxprotobuf

with open(&#39;./douyin_.txt&#39;, &#39;rb&#39;) as f:
    print(blackboxprotobuf.protobuf_to_json(f.read()))
</code></pre>

<p>或者也可以使用官方protoc解析。需要先下载<a href="https://github.com/protocolbuffers/protobuf">protoc</a></p>

<pre class="line-numbers"><code class="language-python">import subprocess


def decodes(data):
    &quot;&quot;&quot;
    如果上传到linux线上服务器，需要chmod+x protoc赋予权限。
    &quot;&quot;&quot;
    process = subprocess.Popen([r&#39;protoc&#39;, &#39;--decode_raw&#39;],
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    output = error = None
    try:
        output, error = process.communicate(data)
    except OSError as e:
        pass
    finally:
        if process.poll() != 0:
            process.wait()
    return output

with open(&#39;./douyin_.txt&#39;, &#39;rb&#39;) as f:
    data = str(decodes(f.read()), encoding=&#39;utf8&#39;)
    print(data)
</code></pre>

<p>但是以上方法均不能拿到对应键值，取数据时比较麻烦。</p>

<h3 id="toc_7">逆向获取proto</h3>

<p>方法来源于这个帖子<a href="https://blog.csdn.net/weixin_38819889/article/details/121050835?spm=1001.2014.3001.5501">抖音直播间弹幕protocbuf分析</a></p>

<p>首先用jadx反编译apk包。因为某音最新版(20.7)安装包较大。本人的16G机器hold不住。所以本人用的是13.9版本的apk包。反编译后通过搜索抓包抓到的接口地址。</p>

<p><img src="media/16520626552663/16530395326677.jpg" alt="" style="width:1172px;"/></p>

<p>之后查看这个类</p>

<p><img src="media/16520626552663/16530395832850.jpg" alt="" style="width:1296px;"/></p>

<p>需要的字段以及类型都在这里了。通过编写简单的脚本生成最终的proto文件。</p>

<pre class="line-numbers"><code class="language-python">import re
import os

OUTPUT_FILENAME = &quot;Sajor.proto&quot;
path = os.getcwd()  # 获取当前路径
listDir = os.listdir(path)

with open(OUTPUT_FILENAME, &#39;w&#39;) as fr:
    fr.write(&#39;syntax = &quot;proto3&quot;;\n\n\n&#39;)

    for file in [i for i in listDir if i.__contains__(&#39;java&#39;)]:

        with open(file, &#39;r&#39;) as f:
            data = f.read()
        res = re.findall(r&#39;@WireField\(adapter = &quot;.*\.(.*?)#(.*?)&quot;,.* tag = (\d+)\)\n.*?public.*? .* (.*?);&#39;, data)

        fr.write(&#39;message %s {\n&#39; % (file.replace(&#39;.java&#39;, &#39;&#39;)))

        for item in res:
            fr.write(&quot;{} {} = {};\n&quot;.format(item[1].lower() if item[0] == &#39;ProtoAdapter&#39; else &#39;repeated {}&#39;.format(item[0]), item[3], item[2]))
        fr.write(&#39;}\n\n&#39;)

print(&quot;---------- end ----------&quot;)
</code></pre>

<p>利用encode函数里的代码生成，更全</p>

<pre class="line-numbers"><code class="language-text">import re
import os

OUTPUT_FILENAME = &quot;Sajor.proto&quot;
path = os.getcwd()  # 获取当前路径
listDir = os.listdir(path)

with open(OUTPUT_FILENAME, &#39;w&#39;) as fr:
    fr.write(&#39;syntax = &quot;proto3&quot;;\n\n\n&#39;)

    for file in [i for i in listDir if i.__contains__(&#39;java&#39;)]:

        with open(file, &#39;r&#39;) as f:
            data = f.read()
        res = re.findall(r&#39;(\w+)\.(.*?)\.encodeWithTag\(protoWriter, (\d+), .*?\.(.*?)\);&#39;, data)

        fr.write(&#39;message %s {\n&#39; % (file.replace(&#39;.java&#39;, &#39;&#39;)))

        for item in res:
            line = &quot;{} {} = {};\n&quot;.format((&#39;repeated {}&#39;.format(item[1].lower().split(&#39;.&#39;)[0]) if item[1].lower().__contains__(&#39;asrepeated&#39;) else item[1].lower()) if item[0] == &#39;ProtoAdapter&#39; else
                                          &#39;repeated {}&#39;.format(item[0]) if item[1] == &#39;ADAPTER.asRepeated()&#39; else item[0],
                                          item[3],
                                          item[2])
            print(line)
            fr.write(line)
        fr.write(&#39;}\n\n&#39;)

print(&quot;---------- end ----------&quot;)
</code></pre>

<p>之后就是通过该proto文件生成对应语言的版本。我这里用的是Python，于是使用该命令生成Python文件</p>

<pre class="line-numbers"><code class="language-bash">protoc ./Sajor.proto --python_out=./ 
</code></pre>

<p>然后使用该文件解析请求返回的数据。</p>

<pre class="line-numbers"><code class="language-text">import json

from google.protobuf.json_format import MessageToDict

from proto import sajor_pb2

with open(&#39;./douyin.txt&#39;, &#39;rb&#39;) as f:
    a = f.read()

info = sajor_pb2.aweme_v2_feed_response()
info.ParseFromString(a)
print(json.dumps(MessageToDict(info, preserving_proto_field_name=True), ensure_ascii=False))
</code></pre>

<p><strong>proto与blackboxprotobuf</strong></p>

<p>blackboxprotobuf是个不错的开源库，但是解析的速度与可靠性有些问题，通过对同一个文件的解析，做个对比。</p>

<p>blackboxprotobuf</p>

<p><img src="media/16520626552663/16533592347511.jpg" alt="" style="width:1333px;"/></p>

<p>proto</p>

<p><img src="media/16520626552663/16533592551492.jpg" alt="" style="width:1354px;"/></p>

<p>那是因为 blackboxprotobuf 在内部是使用递归的方式，逐步猜测要解析数据的类型格式。一不小心就会陷入循环中。。</p>

<p><img src="media/16520626552663/16533597992474.jpg" alt="" style="width:1365px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 开启wsl并开启远程]]></title>
    <link href="http://565785929.github.io/16488664948376.html"/>
    <updated>2022-04-02T10:28:14+08:00</updated>
    <id>http://565785929.github.io/16488664948376.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16488664948376/16528851318715.jpg" alt=""/></p>

<p>首先在linux中启动SSH连接支持</p>

<pre class="line-numbers"><code class="language-text">#客户端
sudo apt-get install openssh-client
#服务器
sudo apt-get install openssh-server
#或
apt-get install ssh
</code></pre>

<p>编辑配置文件</p>

<pre class="line-numbers"><code class="language-text">sudo vi /etc/ssh/sshd_config
</code></pre>

<p>增加以下配置</p>

<pre class="line-numbers"><code class="language-text">Port 2222             # wsl端口
PermitRootLogin yes   # 可以root远程登录
AllowUsers xxx        # 开启wsl时新建的账户
</code></pre>

<p><strong>重启</strong></p>

<p><code>sudo service ssh --full-restart</code></p>

<p>在使用ssh连接时若报错 Disconnected:No supported authentication methods available</p>

<p>是因为 /etc/ssh/sshd_config 中包含 这条配置</p>

<p><code>PasswordAuthentication no</code></p>

<p>我们需要将它注释掉，或改为yes然后重启 ssh服务</p>

<h2 id="toc_0">端口映射</h2>

<p>这个时候自己电脑上的xhell是可以连接的了, 但是想要在其他的计算机上访问, 就需要在windows系统作端口映射了。</p>

<pre class="line-numbers"><code class="language-text"># netsh interface portproxy add v4tov4 listenport=[win10端口] listenaddress=0.0.0.0 connectport=[虚拟机的端口] connectaddress=[虚拟机的ip]
netsh interface portproxy add v4tov4 listenport=22 listenaddress=0.0.0.0 connectport=22 connectaddress=172.22.22.22
 
#检测是否设置成功
netsh interface portproxy show all
 
#删除端口映射
netsh interface portproxy delete v4tov4 listenaddress=监听地址 listenport=监听端口
</code></pre>

<p>此时，即可在其他电脑上用windows的IP和配置的端口进行ssh连接了。若不可以，可以尝试打开windows防火墙，新建一条入站规则 tcp端口为 2223。</p>

<h2 id="toc_1">桌面</h2>

<p>后续可以在wsl中安装桌面程序 例如 <a href="https://baiyue.one/archives/1658.html">KDE</a></p>

<p>参考：<a href="https://blog.csdn.net/weixin_43718675/article/details/106844150">开启WSL(win10的linux子系统)并实现远程连接</a>、<a href="https://blog.csdn.net/lcuwb/article/details/82885920">设置WSL可远程连接</a>、<a href="https://blog.csdn.net/u010328478/article/details/116457769">WSL允许用其他电脑ssh连接</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java8 特性 Optional]]></title>
    <link href="http://565785929.github.io/16487053528391.html"/>
    <updated>2022-03-31T13:42:32+08:00</updated>
    <id>http://565785929.github.io/16487053528391.html</id>
    <content type="html"><![CDATA[
<p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>

<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>

<h2 id="toc_0">创建 Option</h2>

<p>Optional 有两个函数(of &amp; ofNullable)可以传参初始化。一个empty函数没有参数。</p>

<p><img src="media/16487053528391/16487116675343.jpg" alt="" style="width:611px;"/></p>

<h3 id="toc_1">empty</h3>

<p><code>empty</code> 函数就是，直接返回 <code>new Optional()</code> 并且 <code>value</code> 为空 <code>null</code>。</p>

<p><img src="media/16487053528391/16487128365738.jpg" alt="" style="width:1321px;"/></p>

<h3 id="toc_2">of &amp; ofNullable</h3>

<p><strong>of</strong></p>

<p>首先看 <code>of</code> 我们发现这个函数就是将 <code>Optional</code> 中 <code>value</code> 的值赋值为参数传入的 <code>value</code> 值，假如传入的值为空 <code>null</code> 则抛出异常。源码如下：</p>

<p><img src="media/16487053528391/16487121432837.jpg" alt=""/></p>

<p><strong>ofNullable</strong></p>

<p>而 <code>ofNullable</code> 就是将前两个函数 <code>empty</code> 和 <code>of</code> 结合起来，首先判断传入的值 <code>value</code> 是否为空 <code>null</code>， 为空就调用 <code>empty</code> 函数， 不为空就调用 <code>of</code> 函数。</p>

<p><img src="media/16487053528391/16487123039061.jpg" alt=""/></p>

<p>所以一般我们使用 ofNullable 函数来初始化 Optional 对象，方便之后调用它的方法。</p>

<h2 id="toc_3">应用</h2>

<pre class="line-numbers"><code class="language-java">    /**
     * 用于测试的 User 类
     */
    @Data
    @AllArgsConstructor
    public static class User {
        String name;
        int id;
    }
</code></pre>

<p>获取对象下某属性的值，原来需要判断一下 <code>user</code> 是否为空，不为空再获取 <code>name</code> 属性，现在可以通过 <code>orElse</code> 一行实现。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    User user1 = null;
    String u1 = Optional.ofNullable(user1).map(User::getName).orElse(&quot;default&quot;);
    User user2 = new User(null, 12);
    String u2 = Optional.ofNullable(user2).map(User::getName).orElse(&quot;default&quot;);
    User user3 = new User(&quot;Sajor&quot;, 12);
    String u3 = Optional.ofNullable(user3).map(User::getName).orElse(&quot;default&quot;);

    System.out.println(u1);  // default
    System.out.println(u2);  // default
    System.out.println(u3);  // SAJOR
}
</code></pre>

<p>再进一步也可以通过 <code>map</code> 来持续对对象下属性进行更复杂的操作。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    // 通过变大写函数
    String u1 = Optional.ofNullable(user1).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    User user2 = new User(null, 12);
    String u2 = Optional.ofNullable(user2).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    User user3 = new User(&quot;Sajor&quot;, 12);
    String u3 = Optional.ofNullable(user3).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    // 通过过滤
    User user4 = new User(&quot;Sajor&quot;, 12);
    String u4 = Optional.ofNullable(user4).map(User::getName).map(String::toUpperCase).filter(s -&gt; s.equals(&quot;SAJOR&quot;)).orElse(&quot;default&quot;);
    User user5 = new User(&quot;Sajor&quot;, 12);
    String u5 = Optional.ofNullable(user5).map(User::getName).map(String::toUpperCase).filter(s -&gt; s.equals(&quot;sajor&quot;)).orElse(&quot;default&quot;);

    System.out.println(u1);  // default
    System.out.println(u2);  // default
    System.out.println(u3);  // SAJOR
    System.out.println(u4);  // SAJOR
    System.out.println(u5);  // default
}
</code></pre>

<p>也可以通过 <code>ifPresent</code> 函数修改对象下的属性</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    // 修改属性
    User user1 = new User(null, 12);
    Optional.ofNullable(user1).ifPresent(user -&gt; {
        user.setId(13);
        user.setName(&quot;Sajor&quot;);
    });
    User user2 = null;
    Optional.ofNullable(user2).ifPresent(user -&gt; {
        user.setId(13);
        user.setName(&quot;Sajor&quot;);
    });

    System.out.println(user1);  // User(name=Sajor, id=13)
    System.out.println(user2);  // null
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Word Cloud 词云重叠算法]]></title>
    <link href="http://565785929.github.io/16486272439635.html"/>
    <updated>2022-03-30T16:00:43+08:00</updated>
    <id>http://565785929.github.io/16486272439635.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16486272439635/16528852569694.jpg" alt=""/></p>

<p><a href="https://github.com/amueller/word_cloud">word_cloud</a> </p>

<h2 id="toc_0">积分图算法</h2>

<p><img src="media/16486272439635/16486272595252.jpg" alt="" style="width:726px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python pip源 国内源]]></title>
    <link href="http://565785929.github.io/16486184863200.html"/>
    <updated>2022-03-30T13:34:46+08:00</updated>
    <id>http://565785929.github.io/16486184863200.html</id>
    <content type="html"><![CDATA[
<p>pip 安装第三方库速度太慢</p>

<p>可设置 pip 从国内的镜像源下载安装</p>

<pre class="line-numbers"><code class="language-text">阿里云 http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣 http://pypi.douban.com/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/
</code></pre>

<p>设置方法，以清华镜像源为例：</p>

<p>临时使用</p>

<pre class="line-numbers"><code class="language-text">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxxxxxx
</code></pre>

<p>永久设置</p>

<pre class="line-numbers"><code class="language-text">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ngrok 内网穿透]]></title>
    <link href="http://565785929.github.io/16485397489109.html"/>
    <updated>2022-03-29T15:42:28+08:00</updated>
    <id>http://565785929.github.io/16485397489109.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16485397489109/16485401540848.jpg" alt=""/></p>

<p><a href="https://dashboard.ngrok.com/get-started/setup">ngrok</a> 安装和使用太简单了，可以方便今后调试带回调的三方接口。</p>

<p>按照文档保存密钥后，输入 <code>ngrok http 8080</code> 启动</p>

<p><img src="media/16485397489109/16485400843573.jpg" alt="" style="width:781px;"/></p>

<p>图中 Web Interface 的 4040 地址，还可以看到ngrok作为中间人劫持记录到的所有接口文件数据。</p>

<p><img src="media/16485397489109/16485403495497.jpg" alt="" style="width:1400px;"/></p>

<h2 id="toc_0">配置文件</h2>

<p>输入token之后，会自动生成配置文件，我们可以在配置文件里配置我们常用的端口，例如8080。</p>

<pre class="line-numbers"><code class="language-text">tunnels:
  dev:
    proto: http
    addr: 8080
  aria:
    proto: tcp
    addr: 6800
</code></pre>

<p>这样可以直接使用命令 <code>ngrok start dev</code> 只启动名为 dev 的 8080 端口映射。 </p>

<p>也可以使用 <code>ngrok start --all</code> 启动所有映射。</p>

<p>配置属性可参考<a href="https://ngrok.com/docs">文档</a>：</p>

<p><img src="media/16485397489109/16485505636452.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis Codis 第三方集群实现]]></title>
    <link href="http://565785929.github.io/16480451786591.html"/>
    <updated>2022-03-23T22:19:38+08:00</updated>
    <id>http://565785929.github.io/16480451786591.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/CodisLabs/codis">Codis</a> 是 Redis 集群方案之一，令我们感到骄傲的是，它是中国人开发并开源的，来自前豌豆荚中间件团队。</p>

<p>有了 Codis 技术积累之后，项目「突头人」刘奇又开发出来中国人自己的开源分布式数据库 —— <a href="https://github.com/pingcap/tidb">TiDB</a></p>

<p><img src="media/16480451786591/16480452986071.jpg" alt="" style="width:626px;"/></p>

<p>Codis 使用 Go 语言开发，它是一个代理中间件，它和 Redis 一样也使用 Redis 协议对外提供服务，当客户端向 Codis 发送指令时，Codis 负责将指令转发到后面的 Redis 实例来执行，并将返回结果再转回给客户端。</p>

<p><img src="media/16480451786591/16480453431608.jpg" alt="" style="width:492px;"/></p>

<p>Codis 上挂接的所有 Redis 实例构成一个 Redis 集群，当集群空间不足时，可以通过动态增加 Redis 实例来实现扩容需求。</p>

<p>客户端操纵 Codis 同操纵 Redis 几乎没有区别，还是可以使用相同的客户端 SDK，不需要任何变化。</p>

<p>因为 Codis 是无状态的，它只是一个转发代理中间件，这意味着我们可以启动多个 Codis 实例，供客户端使用，每个 Codis 节点都是对等的。因为单个 Codis 代理能支撑的 QPS 比较有限，通过启动多个 Codis 代理可以显著增加整体的 QPS 需求，还能起到容灾功能，挂掉一个 Codis 代理没关系，还有很多 Codis 代理可以继续服务。</p>

<p><img src="media/16480451786591/16480453830021.jpg" alt="" style="width:443px;"/></p>

<h2 id="toc_0">Codis 分片原理</h2>

<p>Codis 要负责将特定的 key 转发到特定的 Redis 实例。Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p>

<p><img src="media/16480451786591/16480836489628.jpg" alt=""/></p>

<p>每个槽位都会唯一映射到后面的多个 Redis 实例之一，Codis 会在内存维护槽位和 Redis 实例的映射关系。这样有了上面 key 对应的槽位，那么它应该转发到哪个 Redis 实例就很明确了。</p>

<pre class="line-numbers"><code class="language-python">hash = crc32(command.key)
slot_index = hash % 1024
redis = slots[slot_index].redis
redis.do(command)
</code></pre>

<p>槽位数量默认是1024，它是可以配置的，如果集群节点比较多，建议将这个数值配置大一些，比如2048、4096。</p>

<h2 id="toc_1">不同的 Codis 实例之间槽位关系如何同步？</h2>

<p>如果 Codis 的槽位映射关系只存储在内存里，那么不同的 Codis 实例之间的槽位关系就无法得到同步。所以 Codis 还需要一个分布式配置存储数据库专门用来持久化槽位关系。Codis 开始使用 ZooKeeper，后来连 etcd 也一块支持了。</p>

<p><img src="media/16480451786591/16480837412388.jpg" alt=""/></p>

<p>Codis 将槽位关系存储在 zk 中，并且提供了一个 Dashboard 可以用来观察和修改槽位关系，当槽位关系变化时，Codis Proxy 会监听到变化并重新同步槽位关系，从而实现多个 Codis Proxy 之间共享相同的槽位关系配置。</p>

<h2 id="toc_2">扩容</h2>

<p>刚开始 Codis 后端只有一个 Redis 实例，1024 个槽位全部指向同一个 Redis。然后一个 Redis 实例内存不够了，所以又加了一个 Redis 实例。这时候需要对槽位关系进行调整，将一半的槽位划分到新的节点。这意味着需要对这一半的槽位对应的所有 key 进行迁移，迁移到新的 Redis 实例。</p>

<p><strong>那 Codis 如何找到槽位对应的所有 key 呢？</strong></p>

<p>Codis 对 Redis 进行了改造，增加了 SLOTSSCAN 指令，可以遍历指定 slot 下所有的 key。Codis 通过 SLOTSSCAN 扫描出待迁移槽位的所有的 key，然后挨个迁移每个 key 到新的 Redis 节点。</p>

<p>在迁移过程中，Codis 还是会接收到新的请求打在当前正在迁移的槽位上，因为当前槽位的数据同时存在于新旧两个槽位中，Codis 如何判断该将请求转发到后面的哪个具体实例呢？</p>

<p>Codis 无法判定迁移过程中的 key 究竟在哪个实例中，所以它采用了另一种完全不同的思路。当 Codis 接收到位于正在迁移槽位中的 key 后，会立即强制对当前的单个 key 进行迁移，迁移完成后，再将请求转发到新的 Redis 实例。</p>

<pre class="line-numbers"><code class="language-text">slot_index = crc32(command.key) % 1024
if slot_index in migrating_slots:
    do_migrate_key(command.key)  # 强制执行迁移
    redis = slots[slot_index].new_redis
else:
    redis = slots[slot_index].redis
redis.do(command)
</code></pre>

<h2 id="toc_3">自动均衡</h2>

<p>Redis 新增实例，手工均衡slots太繁琐，所以 Codis 提供了自动均衡功能。自动均衡会在系统比较空闲的时候观察每个 Redis 实例对应的 Slots 数量，如果不平衡，就会自动进行迁移。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 集群 Sentinel 哨兵模式]]></title>
    <link href="http://565785929.github.io/16476622390377.html"/>
    <updated>2022-03-19T11:57:19+08:00</updated>
    <id>http://565785929.github.io/16476622390377.html</id>
    <content type="html"><![CDATA[
<p>我们必须有一个高可用方案来抵抗节点故障，当故障发生时可以自动进行从主切换，程序可以不用重启，Redis 官方提供了这样一种方案 —— Redis Sentinel(哨兵)。</p>

<p><img src="media/16476622390377/16477425526206.jpg" alt="" style="width:463px;"/></p>

<p>我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。</p>

<p>它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉后，集群将可能自动调整为下图所示结构。</p>

<p><img src="media/16476622390377/16477782314095.jpg" alt="" style="width:520px;"/></p>

<p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经挂掉了主节点，待它恢复后，集群会调整为下面这张图。</p>

<p><img src="media/16476622390377/16477782868816.jpg" alt="" style="width:428px;"/></p>

<p>此时原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系。</p>

<h2 id="toc_0">消息丢失</h2>

<p>Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。Sentinel 无法保证消息完全不丢失，但是也尽可能保证消息少丢失。它有两个选项可以限制主从延迟过大。</p>

<pre class="line-numbers"><code class="language-text">min-slaves-to-write 1
min-slaves-max-lag 10
</code></pre>

<p>第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。</p>

<p>何为正常复制，何为异常复制？这个就是由第二个参数控制的，它的单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</p>

<h2 id="toc_1">Sentinel 基本使用</h2>

<p>接下来我们看看客户端如何使用 sentinel，标准的流程应该是客户端可以通过 sentinel 发现主从节点的地址，然后在通过这些地址建立相应的连接来进行数据存取操作。我们来看看 Python 客户端是如何做的。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; from redis.sentinel import Sentinel
&gt;&gt;&gt; sentinel = Sentinel([(&#39;localhost&#39;, 26379)], socket_timeout=0.1)
&gt;&gt;&gt; sentinel.discover_master(&#39;mymaster&#39;)
(&#39;127.0.0.1&#39;, 6379)
&gt;&gt;&gt; sentinel.discover_slaves(&#39;mymaster&#39;)
[(&#39;127.0.0.1&#39;, 6380)]
</code></pre>

<p>sentinel 的默认端口是 26379，不同于 Redis 的默认端口 6379，通过 sentinel 对象的 discover_xxx 方法可以发现主从地址，主地址只有一个，从地址可以有多个。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; master = sentinel.master_for(&#39;mymaster&#39;, socket_timeout=0.1)
&gt;&gt;&gt; slave = sentinel.slave_for(&#39;mymaster&#39;, socket_timeout=0.1)
&gt;&gt;&gt; master.set(&#39;foo&#39;, &#39;bar&#39;)
&gt;&gt;&gt; slave.get(&#39;foo&#39;)
&#39;bar&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 集群-主从同步]]></title>
    <link href="http://565785929.github.io/16475965636227.html"/>
    <updated>2022-03-18T17:42:43+08:00</updated>
    <id>http://565785929.github.io/16475965636227.html</id>
    <content type="html"><![CDATA[
<p>主从复制是 Redis 分布式的基础，Redis 的高可用离开了主从复制将无从进行。</p>

<p>不过复制功能也不是必须的，如果你将 Redis 只用来做缓存，跟 memcache 一样来对待，也就无需要从库做备份，挂掉了重新启动一下就行。但是只要你使用了 Redis 的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>

<h2 id="toc_0">CAP 原理</h2>

<p>现代分布式系统的理论基石——CAP 原理，CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</p>

<ul>
<li><strong>C</strong> - Consistent ，一致性</li>
<li><strong>A</strong> - Availability ，可用性</li>
<li><strong>P</strong> - Partition tolerance ，分区容忍性</li>
</ul>

<p><img src="media/16475965636227/16475969218160.jpg" alt="" style="width:704px;"/></p>

<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「<strong>网络分区</strong>」。</p>

<p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「<strong>一致性</strong>」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「<strong>可用性</strong>」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p>

<p><img src="media/16475965636227/16475970141647.jpg" alt="" style="width:415px;"/></p>

<p>一句话概括 CAP 原理就是——<strong>网络分区发生时，一致性和可用性两难全</strong>。</p>

<h2 id="toc_1">最终一致</h2>

<p>Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「<strong>一致性</strong>」要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「<strong>可用性</strong>」。</p>

<p>Redis 保证「<strong>最终一致性</strong>」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。</p>

<p><img src="media/16475965636227/16476122373622.jpg" alt="" style="width:688px;"/></p>

<h2 id="toc_2">主从同步</h2>

<p>Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。</p>

<p><img src="media/16475965636227/16476121091943.jpg" alt="" style="width:520px;"/></p>

<h2 id="toc_3">增量同步</h2>

<p>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了 (偏移量)。</p>

<p>因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer 中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。</p>

<p><img src="media/16475965636227/16475988392974.jpg" alt="" style="width:183px;"/></p>

<p>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 —— 快照同步。</p>

<h2 id="toc_4">快照同步</h2>

<p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。</p>

<p>在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。</p>

<p><img src="media/16475965636227/16475988707034.jpg" alt="" style="width:435px;"/></p>

<p>所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</p>

<h2 id="toc_5">增加从节点</h2>

<p>当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增量同步。</p>

<h2 id="toc_6">无盘复制</h2>

<p>主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。</p>

<p>所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。</p>

<h2 id="toc_7">Wait 指令</h2>

<p>Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。</p>

<pre class="line-numbers"><code class="language-text">&gt; set key value
OK
&gt; wait 1 0
(integer) 1
</code></pre>

<p>wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到 N 个从库同步完成达成一致。</p>

<p>假设此时出现了网络分区，wait 指令第二个参数时间 t=0，主从同步无法继续进行，wait 指令会永远阻塞，Redis 服务器将丧失可用性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 基数树]]></title>
    <link href="http://565785929.github.io/16474851306463.html"/>
    <updated>2022-03-17T10:45:30+08:00</updated>
    <id>http://565785929.github.io/16474851306463.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 紧凑列表]]></title>
    <link href="http://565785929.github.io/16474851167642.html"/>
    <updated>2022-03-17T10:45:16+08:00</updated>
    <id>http://565785929.github.io/16474851167642.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 跳跃列表]]></title>
    <link href="http://565785929.github.io/16474851118548.html"/>
    <updated>2022-03-17T10:45:11+08:00</updated>
    <id>http://565785929.github.io/16474851118548.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 快速列表]]></title>
    <link href="http://565785929.github.io/16474850990931.html"/>
    <updated>2022-03-17T10:44:59+08:00</updated>
    <id>http://565785929.github.io/16474850990931.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
</feed>
