<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2022-01-05T11:29:42+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim 跳转技巧]]></title>
    <link href="http://565785929.github.io/16413527990433.html"/>
    <updated>2022-01-05T11:19:59+08:00</updated>
    <id>http://565785929.github.io/16413527990433.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16413527990433/16413528368917.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412884491803.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412867101612.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412866952994.jpg" alt=""/></p>

<p><img src="media/16405110285297/16412886197662.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tmux]]></title>
    <link href="http://565785929.github.io/16408435425370.html"/>
    <updated>2021-12-30T13:52:22+08:00</updated>
    <id>http://565785929.github.io/16408435425370.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16408435425370/16408437247844.jpg" alt=""/></p>

<h2 id="toc_0">安装</h2>

<p>使用包管理工具</p>

<pre class="line-numbers"><code class="language-text"># Ubuntu 或 Debian
$ sudo apt-get install tmux

# CentOS 或 Fedora
$ sudo yum install tmux

# Mac
$ brew install tmux
</code></pre>

<h2 id="toc_1">session 会话管理</h2>

<h3 id="toc_2">1. 新建会话</h3>

<p>第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>

<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>

<pre class="line-numbers"><code class="language-text">$ tmux new -s &lt;session-name&gt;
</code></pre>

<p>上面命令新建一个指定名称的会话。</p>

<h3 id="toc_3">2. 分离会话</h3>

<p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>

<pre class="line-numbers"><code class="language-text">$ tmux detach
</code></pre>

<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>

<p>tmux ls命令可以查看当前所有的 Tmux 会话。</p>

<pre class="line-numbers"><code class="language-text">$ tmux ls
# or
$ tmux list-session
</code></pre>

<h3 id="toc_4">3. 接入会话</h3>

<p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_5">4. 杀死会话</h3>

<p><code>tmux kill-session</code>命令用于杀死某个会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux kill-session -t 0

# 使用会话名称
$ tmux kill-session -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_6">5. 切换会话</h3>

<p><code>tmux switch</code>命令用于切换会话。</p>

<pre class="line-numbers"><code class="language-text"># 使用会话编号
$ tmux switch -t 0

# 使用会话名称
$ tmux switch -t &lt;session-name&gt;
</code></pre>

<h3 id="toc_7">6. 重命名会话</h3>

<p><code>tmux rename-session</code>命令用于重命名会话。</p>

<pre class="line-numbers"><code class="language-text">$ tmux rename-session -t 0 &lt;new-name&gt;
上面命令将0号会话重命名。
</code></pre>

<h3 id="toc_8">7. 会话快捷键</h3>

<p>下面是一些会话相关的快捷键。</p>

<pre class="line-numbers"><code class="language-text">Ctrl+b d：分离当前会话。
Ctrl+b s：列出所有会话。
Ctrl+b $：重命名当前会话。
</code></pre>

<h3 id="toc_9">session 总结</h3>

<p>session 在 tmux 操作当中非常重要，希望你可以熟练的使用以上操作：</p>

<p>新建 session -&gt; 离开 session -&gt; 查看 session 列表 -&gt; 进入 session -&gt; 关闭 session -&gt; 不同 session 之间的切换 -&gt; 重命名 session</p>

<pre class="line-numbers"><code class="language-text">tmux new -s &lt;session-name&gt;
tmux detach                                      # Ctrl+b d 
tmux ls                                          # Ctrl+b s
tmux attach -t &lt;session-name&gt; 
tmux kill-session -t &lt;session-name&gt;              # Ctrl+d
tmux switch -t &lt;session-name&gt;
tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;     # Ctrl+b $
</code></pre>

<h2 id="toc_10">pane 窗格管理</h2>

<p>待续。</p>

<p>来源：<a href="https://zhuanlan.zhihu.com/p/102546608">知乎</a>、<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰的网络日志</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 内存模型]]></title>
    <link href="http://565785929.github.io/16405110285297.html"/>
    <updated>2021-12-26T17:30:28+08:00</updated>
    <id>http://565785929.github.io/16405110285297.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 类加载器]]></title>
    <link href="http://565785929.github.io/16405090873022.html"/>
    <updated>2021-12-26T16:58:07+08:00</updated>
    <id>http://565785929.github.io/16405090873022.html</id>
    <content type="html"><![CDATA[
<p>类的生命周期：</p>

<ul>
<li>加载：找到Class文件</li>
<li>验证：验证格式、依赖</li>
<li>准备：静态字段、方法表</li>
<li>解析：符号解析为引用</li>
<li>初始化：构造器、静态变量赋值、静态代码块</li>
<li>使用</li>
<li>卸载</li>
</ul>

<p><img src="media/16405090873022/16405092178762.jpg" alt="" style="width:402px;"/></p>

<h2 id="toc_0">类的加载时机</h2>

<p><img src="media/16405090873022/16405097616339.jpg" alt="" style="width:735px;"/></p>

<ol>
<li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；</li>
<li>当遇到用以新建目标类示例的new指令时，初始化new指定的目标类，就是new一个类的时候要初始化；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态方法所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射API对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么事已经有实例了，要么是静态方法，都需要初始化；</li>
<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类；</li>
</ol>

<h2 id="toc_1">不会初始化（可能会加载）</h2>

<p><img src="media/16405090873022/16405099836639.jpg" alt="" style="width:733px;"/></p>

<h2 id="toc_2">三类加载器</h2>

<ol>
<li>启动类加载器</li>
<li>拓展类加载器</li>
<li>应用类加载器</li>
</ol>

<p><strong>加载器特点</strong></p>

<ol>
<li>双亲委托</li>
<li>负责依赖</li>
<li>缓存加载</li>
</ol>

<p><img src="media/16405090873022/16405101923617.jpg" alt="" style="width:835px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 字节码]]></title>
    <link href="http://565785929.github.io/16405067982525.html"/>
    <updated>2021-12-26T16:19:58+08:00</updated>
    <id>http://565785929.github.io/16405067982525.html</id>
    <content type="html"><![CDATA[
<p>有一个简单的类 </p>

<pre class="line-numbers"><code class="language-text">class Hello {
        public static void main(String[] agrs) {
                Hello obj = new Hello();
        }
}
</code></pre>

<p>编译：<code>javac Hello.java</code><br/>
查看字节码：<code>javap -c Hello.class</code></p>

<p><img src="media/16405067982525/16405070154518.jpg" alt="" style="width:613px;"/></p>

<p>运算应在栈上操作，所以应该先将变量从本地变量表中加载到栈上，运算完成后再储存回本地变量表。</p>

<p><img src="media/16405067982525/16405072357620.jpg" alt="" style="width:220px;"/></p>

<p>更详细的内容：<code>javap -c -verbose Hello.class</code></p>

<pre class="line-numbers"><code class="language-text">&gt;&gt; javap -c -verbose ./Hello.class

Classfile /Users/sajor/Desktop/jvm/Hello.class
  Last modified 2021-12-26; size 272 bytes
  MD5 checksum ad7dbc8f3a6688a6991501a51cebaa71
  Compiled from &quot;Hello.java&quot;
class Hello
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#13         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #14            // Hello
   #3 = Methodref          #2.#13         // Hello.&quot;&lt;init&gt;&quot;:()V
   #4 = Class              #15            // java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               main
  #10 = Utf8               ([Ljava/lang/String;)V
  #11 = Utf8               SourceFile
  #12 = Utf8               Hello.java
  #13 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V
  #14 = Utf8               Hello
  #15 = Utf8               java/lang/Object
{
  Hello();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class Hello
         3: dup
         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: return
      LineNumberTable:
        line 3: 0
        line 4: 8
}
SourceFile: &quot;Hello.java&quot;
</code></pre>

<p><img src="media/16405067982525/16405076823829.jpg" alt="" style="width:816px;"/></p>

<p>算数操作与类型转换</p>

<p><img src="media/16405067982525/16405079652324.jpg" alt="" style="width:743px;"/></p>

<h2 id="toc_0">小例子：</h2>

<pre class="line-numbers"><code class="language-java">class Hello {
        public static void main(String[] agrs) {
                int a = 2;
                int b = 1;
                int c = a + b * 5;
        }
}
</code></pre>

<p>字节码为如下</p>

<p><img src="media/16405067982525/16405090059683.jpg" alt="" style="width:596px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Final Shell离线激活]]></title>
    <link href="http://565785929.github.io/16402262289586.html"/>
    <updated>2021-12-23T10:23:48+08:00</updated>
    <id>http://565785929.github.io/16402262289586.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16402262289586/16413518433356.jpg" alt=""/></p>

<h2 id="toc_0">使用FinalShell离线激活方式升级高级版本</h2>

<p>使用FinalShell离线激活方式升级高级版本</p>

<p><img src="media/16402262289586/16413519039476.jpg" alt=""/></p>

<p>获取机器码(如果没有就随意输入用户名或密码执行登录)</p>

<p><img src="media/16402262289586/16413519102850.jpg" alt=""/></p>

<p>执行下面代码,输入机器码获取激活码<br/>
<img src="media/16402262289586/16413520061027.jpg" alt=""/></p>

<pre class="line-numbers"><code class="language-text">import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;


class FinalShell {
    public static void main(String[] args) throws NoSuchAlgorithmException, IOException {
        System.out.print(&quot;请输入FinalShell的离线机器码：&quot;);
        Scanner reader = new Scanner(System.in);
        String machineCode = reader.nextLine();
        generateKey(machineCode);
    }

    public static void generateKey(String hardwareId) throws NoSuchAlgorithmException {
        String proKey = transform(61305 + hardwareId + 8552);
        String pfKey = transform(2356 + hardwareId + 13593);
        System.out.println(&quot;请将此行复制到离线激活中：&quot; + proKey);
        System.out.println(pfKey);
    }

    public static String transform(String str) throws NoSuchAlgorithmException {

        String md5 = hashMD5(str);

        return hashMD5(str).substring(8, 24);
    }

    public static String hashMD5(String str) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);
        byte[] hashed = digest.digest(str.getBytes());
        StringBuilder sb = new StringBuilder();
        for (byte b : hashed) {
            int len = b &amp; 0xFF;
            if (len &lt; 16) {
                sb.append(&quot;0&quot;);
            }
            sb.append(Integer.toHexString(len));
        }
        return sb.toString();
    }
}
</code></pre>

<p>成功激活</p>

<p><img src="media/16402262289586/16413520217200.jpg" alt=""/></p>

<p>来源：<a href="http://www.cxyax.com/?post=490">FinalShell 离线激活</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置ssh免密码登陆 不生效]]></title>
    <link href="http://565785929.github.io/16378305266660.html"/>
    <updated>2021-11-25T16:55:26+08:00</updated>
    <id>http://565785929.github.io/16378305266660.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16378305266660/16413525261167.jpg" alt=""/></p>

<h2 id="toc_0">问题：</h2>

<p>设置ssh免密码登陆的时候，发现有一些机器设置不生效。有一些机器正常。</p>

<h2 id="toc_1">跟踪</h2>

<p>登陆目标机器，查看sshd的日志信息。日志信息目录为，/var/log/secure<br/>
你会发现如下字样的日志信息。</p>

<pre class="line-numbers"><code class="language-text">Jul 22 14:20:33 v138020.go sshd[4917]: Authentication refused: bad ownership or modes for directory /home/xinhailong
</code></pre>

<h2 id="toc_2">原因</h2>

<p>sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。<br/>
用户目录权限为 755 或者 700，就是不能是77x。<br/>
.ssh目录权限一般为755或者700。<br/>
rsa_id.pub 及authorized_keys权限一般为644<br/>
rsa_id权限必须为600</p>

<h2 id="toc_3">解决方法</h2>

<p>检测目录权限，把不符合要求的按要求设置权限即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 更新 node 版本]]></title>
    <link href="http://565785929.github.io/16353269752301.html"/>
    <updated>2021-10-27T17:29:35+08:00</updated>
    <id>http://565785929.github.io/16353269752301.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16353269752301/16413526184515.jpg" alt=""/></p>

<p>第一步，先查看本机node.js版本：</p>

<p>node -v</p>

<p>第二步，清除node.js的cache：</p>

<p>sudo npm cache clean -f</p>

<p>第三步，安装 n 工具，这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 &quot;n&quot;</p>

<p>sudo npm install -g n</p>

<p>第四步，安装最新版本的node.js</p>

<p>sudo n stable</p>

<p>第五步，再次查看本机的node.js版本：</p>

<p>node -v</p>

<p>第六步，更新npm到最新版：</p>

<p>$ sudo npm install npm@latest -g</p>

<p>第七步，验证</p>

<p>node -v<br/>
npm -v</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[join 语句]]></title>
    <link href="http://565785929.github.io/16351769421565.html"/>
    <updated>2021-10-25T23:49:02+08:00</updated>
    <id>http://565785929.github.io/16351769421565.html</id>
    <content type="html"><![CDATA[
<p>I</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14 | count(*)这么慢，我该怎么办？]]></title>
    <link href="http://565785929.github.io/16345712700520.html"/>
    <updated>2021-10-18T23:34:30+08:00</updated>
    <id>http://565785929.github.io/16345712700520.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">count(*) 的实现方式</h2>

<p>你首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>

<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>

<p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。</p>

<h2 id="toc_1">计数的几种方式</h2>

<ul>
<li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>

<h2 id="toc_2">不同的 count 用法</h2>

<p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>

<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>

<ul>
<li>server 层要什么就给什么；</li>
<li>InnoDB 只给必要的值；</li>
<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>
</ul>

<p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>

<p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>

<p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>

<p><strong>对于 count(字段) 来说</strong>：</p>

<ol>
<li><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</p></li>
<li><p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p></li>
</ol>

<p>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</p>

<p><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[13 重构数据库]]></title>
    <link href="http://565785929.github.io/16345707563290.html"/>
    <updated>2021-10-18T23:25:56+08:00</updated>
    <id>http://565785929.github.io/16345707563290.html</id>
    <content type="html"><![CDATA[
<p>GitHub&#39;s Online Schema Migrations for MySQL<br/>
(<a href="https://github.com/github/gh-ost">https://github.com/github/gh-ost</a>)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 系统的启动过程]]></title>
    <link href="http://565785929.github.io/16343110664613.html"/>
    <updated>2021-10-15T23:17:46+08:00</updated>
    <id>http://565785929.github.io/16343110664613.html</id>
    <content type="html"><![CDATA[
<ul>
<li>内核的引导</li>
<li>运行init</li>
<li>系统初始化</li>
<li>建立终端 </li>
<li>用户登录系统</li>
</ul>

<p><img src="media/16343110664613/16343111820817.jpg" alt=""/></p>

<h2 id="toc_0">内核引导</h2>

<p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>

<p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>

<h2 id="toc_1">运行init</h2>

<p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>

<p>init 程序首先是需要读取配置文件 /etc/inittab。</p>

<h2 id="toc_2">运行级别</h2>

<p>许多程序需要开机启动。它们在Windows叫做&quot;服务&quot;（service），在Linux就叫做&quot;守护进程&quot;（daemon）。</p>

<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>

<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>

<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;（runlevel）。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栈 队列 双端队列（Stack & Queue & Deque）]]></title>
    <link href="http://565785929.github.io/16341349844977.html"/>
    <updated>2021-10-13T22:23:04+08:00</updated>
    <id>http://565785929.github.io/16341349844977.html</id>
    <content type="html"><![CDATA[
<p><a href="http://www.bigocheatsheet.com">www.bigocheatsheet.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[numpy]]></title>
    <link href="http://565785929.github.io/16339276945488.html"/>
    <updated>2021-10-11T12:48:14+08:00</updated>
    <id>http://565785929.github.io/16339276945488.html</id>
    <content type="html"><![CDATA[
<p>用于高性能科学计算和数据分析，是常用的高级数据分析库的基础包</p>

<h1 id="toc_0">pandas</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 217.存在重复元素]]></title>
    <link href="http://565785929.github.io/16332772077185.html"/>
    <updated>2021-10-04T00:06:47+08:00</updated>
    <id>http://565785929.github.io/16332772077185.html</id>
    <content type="html"><![CDATA[
<p>题目链接：<a href="https://leetcode-cn.com/problems/contains-duplicate/">contains-duplicate</a></p>

<blockquote>
<p>给定一个整数数组，判断是否存在重复元素。</p>

<p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>

<p>示例 1:</p>

<p>输入: [1,2,3,1]<br/>
输出: true<br/>
示例 2:</p>

<p>输入: [1,2,3,4]<br/>
输出: false<br/>
示例 3:</p>

<p>输入: [1,1,1,3,3,4,3,2,4,2]<br/>
输出: true</p>
</blockquote>

<h2 id="toc_0">思考</h2>

<p>此方法无法通过用例，Time Limit Exceeded。所以需要优化。</p>

<p>解法一、暴力 \(O(n^2)\)</p>

<pre class="line-numbers"><code class="language-python3">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        for i in range(len(nums) - 1):
            for j in range(i+1, len(nums)):
                if nums[i] == nums[j]:
                    return True
        return False
</code></pre>

<p>解法二、集合 \(O(n)\)</p>

<pre class="line-numbers"><code class="language-python3">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        return len(nums) != len(set(nums))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 1. 两数之和]]></title>
    <link href="http://565785929.github.io/16332745656703.html"/>
    <updated>2021-10-03T23:22:45+08:00</updated>
    <id>http://565785929.github.io/16332745656703.html</id>
    <content type="html"><![CDATA[
<p>题目链接：<a href="https://leetcode-cn.com/problems/two-sum/">two-sum</a></p>

<p><strong>题目</strong></p>

<blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br/>
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br/>
你可以按任意顺序返回答案。</p>

<p>示例 1：<br/>
输入：nums = [2,7,11,15], target = 9<br/>
输出：[0,1]<br/>
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>

<p>示例 2：<br/>
输入：nums = [3,2,4], target = 6<br/>
输出：[1,2]</p>

<p>示例 3：<br/>
输入：nums = [3,3], target = 6<br/>
输出：[0,1]</p>

<p>提示：<br/>
2 &lt;= nums.length &lt;= 104<br/>
-109 &lt;= nums[i] &lt;= 109<br/>
-109 &lt;= target &lt;= 109<br/>
只会存在一个有效答案<br/>
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
</blockquote>

<h2 id="toc_0">思考</h2>

<p>一般套路呢，就是先写个暴力，此题暴力时间复杂度为\(O(n^2)\)，然后根据暴力的结果，寻找重复计算，或可以优化存储的点来突破，一般都是升维或用空间换时间。</p>

<p>解法一、暴力 \(O(n^2)\)</p>

<pre class="line-numbers"><code class="language-python3">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        size = len(nums)
        for i in range(0, size-1):
            for j in range(i+1, size):
                if nums[i] + nums[j] == target:
                    return(i, j)
        return None
</code></pre>

<p>解法二、哈希表 \(O(n)\)</p>

<pre class="line-numbers"><code class="language-python3">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        dic = {}
        for i, item in enumerate(nums):
            if target - item in dic:
                return dic[target - item], i
            dic[item] = i
        return None
</code></pre>

<h2 id="toc_1">涨知识</h2>

<p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>

<p><strong>语法</strong><br/>
以下是 enumerate() 方法的语法:</p>

<p>enumerate(sequence, [start=0])</p>

<p><strong>参数</strong></p>

<ul>
<li>sequence -- 一个序列、迭代器或其他支持迭代对象。</li>
<li>start -- 下标起始位置。</li>
</ul>

<p><strong>普通循环</strong></p>

<pre class="line-numbers"><code class="language-python3">&gt;&gt;&gt; lis = [9,8,7]
&gt;&gt;&gt; for i in range(len(lis)):
...     print(i, lis[i])
...
(0, 9)
(1, 8)
(2, 7)
</code></pre>

<p><strong>enumerate循环</strong></p>

<pre class="line-numbers"><code class="language-python3">&gt;&gt;&gt; lis = [9,8,7]
&gt;&gt;&gt; for i, item in enumerate(lis):
...     print(i, item)
...
(0, 9)
(1, 8)
(2, 7)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arts打卡]]></title>
    <link href="http://565785929.github.io/16332743074800.html"/>
    <updated>2021-10-03T23:18:27+08:00</updated>
    <id>http://565785929.github.io/16332743074800.html</id>
    <content type="html"><![CDATA[
<p>什么是ARTS打卡计划？</p>

<p><img src="media/16332743074800/16413529946427.jpg" alt=""/></p>

<h2 id="toc_0">Algorithm</h2>

<p>每周至少做一个leetcode的算法题。主要是为了编程训练和学习。</p>

<h2 id="toc_1">Review</h2>

<p>阅读并点评至少一片英文技术文章。主要是为了学习英文，如果你英文不行，你基本上无缘技术高手。</p>

<h2 id="toc_2">Tips</h2>

<p>学习至少一个技术技巧。主要是为了总结和归纳你在日常工作中所遇到的知识点。</p>

<h2 id="toc_3">Share</h2>

<p>分享一篇有观点和思考的技术文章。主要是为了建立你的影响力，能够输出价值观。</p>

<h1 id="toc_4">LeetCode刷题法</h1>

<h2 id="toc_5">第一遍</h2>

<ul>
<li>5mins 读题+思考</li>
<li>直接看解法：比较各个解法优劣</li>
<li>背诵并默写好的解法<br/>
## 第二遍</li>
<li>马上自己写 -&gt; 提交LeetCode</li>
<li>多种解法比较、体会 -&gt; 优化</li>
</ul>

<h2 id="toc_6">第三遍</h2>

<ul>
<li>过了一天之后，再重复做题</li>
<li>不同解法的熟练程度 -&gt; 专项练习</li>
</ul>

<h2 id="toc_7">第四遍</h2>

<ul>
<li>过了一周：反复回来练习不熟练的</li>
</ul>

<h2 id="toc_8">第五遍</h2>

<ul>
<li>面试前一周恢复性训练</li>
</ul>

<p>要看国际站的题解 discuss</p>

<p><a href="https://www.markhneedham.com/blog/2008/09/15/clean-code-book-review/">https://www.markhneedham.com/blog/2008/09/15/clean-code-book-review/</a></p>

<h1 id="toc_9">学习方法</h1>

<p>来自于 <outliers> 异类: 不一样的成功启示录</p>

<p><img src="media/16321235553115/16322371489779.jpg" alt="" style="width:184px;"/></p>

<ul>
<li>Chunk it up 切碎知识点</li>
<li>Deliberate Practicing 刻意练习</li>
<li>feedback 反馈</li>
</ul>

<p><a href="http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c">数据结构脑图</a><br/>
<a href="http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec">算法脑图</a></p>

<h2 id="toc_10">Chunk it up</h2>

<p>做脑图</p>

<p>来自reddit中ask me anything<br/>
<img src="media/16321235553115/16321238197078.jpg" alt="" style="width:812px;"/></p>

<h2 id="toc_11">数据结构分类</h2>

<ul>
<li>一维数据结构
<ul>
<li>基础</li>
<li>数组 array(string)</li>
<li>链表 linked list</li>
<li>高级</li>
<li>栈 stack</li>
<li>队列 queue</li>
<li>双端队列 deque(double-ended queue)</li>
<li>集合 set</li>
<li>映射 map(hash or map)</li>
</ul></li>
<li>二维数据结构
<ul>
<li>基础：</li>
<li>树 tree</li>
<li>图 graph</li>
<li>高级：</li>
<li>二叉搜索树 binary search tree(red-black tree, AVL)</li>
<li>堆 heap</li>
<li>并查集 disjoint set</li>
<li>字典树 trie</li>
</ul></li>
<li>特殊数据结构
<ul>
<li>位运算 bitwise</li>
<li>布隆过滤器 BloomFilter</li>
<li>缓存 LRU Cache</li>
</ul></li>
</ul>

<p><strong>切题四件套</strong></p>

<ul>
<li>Clarification 明确题意</li>
<li>Possible solutions 思考多种方法
<ul>
<li>compare(time/space) 对比复杂度</li>
<li>optimal 加强优化</li>
</ul></li>
<li>Coding 多写</li>
<li>Test cases 用例</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[11 | 怎么给字符串字段加索引？]]></title>
    <link href="http://565785929.github.io/16330152348133.html"/>
    <updated>2021-09-30T23:20:34+08:00</updated>
    <id>http://565785929.github.io/16330152348133.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是前缀索引？</h2>

<p>给email字符串创建索引有</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; alter table SUser add index index1(email);
或
mysql&gt; alter table SUser add index index2(email(6));
</code></pre>

<p>索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p>

<p>由于email(6)这个索引结构中每个邮箱字段都只取前6个字节，所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p>

<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>

<h2 id="toc_1">定义多长的前缀？</h2>

<p>我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>

<p>首先，算出这个列上有多少个不同的值</p>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; select 
  count(distinct email) as L,
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7
from SUser;
</code></pre>

<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p>

<h2 id="toc_2">前缀索引对覆盖索引的影响</h2>

<p>使用前缀索引用不上覆盖索引对查询性能的优化</p>

<p>虽然你创建了联合索引，查询字段已经覆盖在联合索引中了，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p>

<h2 id="toc_3">其他方式</h2>

<p>第一种方式是使用<strong>倒序存储</strong>。如果你存储身份证号的时候把它倒过来存，由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p>

<p>每次查询的时候，你可以这么写：</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; select field_list from t where id_card = reverse(&#39;input_id_card_string&#39;);
</code></pre>

<p>第二种方式是<strong>使用hash字段</strong>。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);
</code></pre>

<p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p>

<p>这样，索引的长度变成了4个字节，比原来小了很多。</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; select field_list from t where id_card_crc=crc32(&#39;input_id_card_string&#39;) and id_card=&#39;input_id_card_string&#39;
</code></pre>

<h2 id="toc_4">使用倒序存储和使用hash字段这两种方法的异同点。</h2>

<p>首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。</p>

<p>它们的区别，主要体现在以下三个方面：</p>

<ul>
<li><p>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</p></li>
<li><p>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</p></li>
<li><p>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</p></li>
</ul>

<h2 id="toc_5">小结</h2>

<p>字符串字段创建索引的场景，你可以使用的方式有：</p>

<ol>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>

<p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除远端 .idea 配置文件]]></title>
    <link href="http://565785929.github.io/16329877758446.html"/>
    <updated>2021-09-30T15:42:55+08:00</updated>
    <id>http://565785929.github.io/16329877758446.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16329877758446/16413513618923.jpg" alt=""/></p>

<p>进入项目根目录</p>

<pre class="line-numbers"><code class="language-text">$ cd /c/users/john/blog/
</code></pre>

<p>删除缓存区.idea（保留工作区.idea）</p>

<pre class="line-numbers"><code class="language-text">$ git rm --cached -r .idea
</code></pre>

<p>提交.gitiginore文件，将.idea从源代码仓库中删除（-m 表示注解）</p>

<pre class="line-numbers"><code class="language-text">$ git commit -m &quot;commit and remove .idea&quot;
</code></pre>

<p>推送到远程端</p>

<pre class="line-numbers"><code class="language-text">$ git push
</code></pre>

<p>来源：<a href="https://www.cnblogs.com/ifme/p/11796311.html">git删除远程.idea目录</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化]]></title>
    <link href="http://565785929.github.io/16324912353122.html"/>
    <updated>2021-09-24T21:47:15+08:00</updated>
    <id>http://565785929.github.io/16324912353122.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">性能常用指标</h3>

<h4 id="toc_1">性能</h4>

<ul>
<li>QPS 每秒查询的数量</li>
<li>TPS 每秒事务的数量</li>
<li>HPS 每秒HTTP请求数量</li>
</ul>

<h4 id="toc_2">高并发的互联网应用</h4>

<ul>
<li>响应速度 是穿行执行的优化，通过优化执行步骤解决问题</li>
<li>吞吐量 是并行执行的优化，通过合理利用计算资源达到目标</li>
</ul>

<p>高吞吐高并发，使用有限的硬件资源，从中找到一个平衡点</p>

<h4 id="toc_3">指标</h4>

<ul>
<li>平均响应时间</li>
<li>百分位数（Percentile） 可以反映出应用接口的整体响应情况。 目标要干掉严重影响系统的长尾请求。 例如 TP50%=40ms 指的是百分之九十的数据可以在四十毫秒内返回。</li>
<li>并发量  指系统同时能处理的请求数量，这个指标反映了系统的负载能力。高并发时会导致共享资源争用问题，需要减少资源冲突，以及长时间占用资源的行为。</li>
<li>秒开率 APP启动速度</li>
<li>容错率 </li>
<li>正确性 项目中使用了熔断</li>
</ul>

<h4 id="toc_4">优化理论方法</h4>

<ul>
<li>木桶理论：系统的整体性能，取决于系统中最慢的组件。例如数据库落盘的I/O问题</li>
<li>基础测试（Benchmark）：是用来测试某个程序的最佳性能。Java组件中的JMH可以消除刚启动的应用JIT编辑器等因素的影响。</li>
<li>Amdahl</li>
</ul>

<h4 id="toc_5">性能优化注意点</h4>

<ul>
<li>依据数字而不是猜想</li>
<li>个体数据不足信</li>
<li>不要过早优化和过度优化
<ul>
<li>项目开发和性能优化应该分为两个独立的步骤。性能优化应等到整个项目的架构和功能大体进入稳定状态再进行。</li>
</ul></li>
<li>保持良好的代码规范
<ul>
<li>使用合适的设计模式</li>
</ul></li>
</ul>

<h3 id="toc_6">性能优化点</h3>

<ul>
<li>复用优化 </li>
<li>计算优化</li>
<li>结果集优化</li>
<li>资源冲突优化</li>
<li>JVM优化</li>
<li>算法优化</li>
<li>高效实现</li>
</ul>

<h4 id="toc_7">复用优化</h4>

<p>例如写代码时会发现有很多重复的代码可以提取出来，做成公共的方法，下次用的时候，就不用再写一遍。</p>

<p>复用</p>

<ul>
<li>缓冲(buffer): 常见于对数据的暂存，然后批量传输或者写入。多使用顺序的方式，用来缓解不同设备之间频繁地、缓慢地随机写</li>
<li>缓存(cache): 常见于对已读数据的复用。通过将它们缓存在相对高速的区域，缓存主要针对于读操作
<ul>
<li>数据缓存</li>
<li>计算结果缓存</li>
<li>多层缓存</li>
</ul></li>
<li>池化: 连接池</li>
<li>过载优化</li>
</ul>

<h4 id="toc_8">计算优化</h4>

<p>并行执行</p>

<ul>
<li>多机 多台计算机 hadoop</li>
<li>多进程 nginx</li>
<li>多线程 netty </li>
<li>协程 go </li>
</ul>

<p>变同步为异步<br/>
惰性加载</p>

<h4 id="toc_9">结果集优化</h4>

<p>xml- json<br/>
gzip</p>

<p>返回数据集的精简</p>

<p>对于时效性要求不高，但对处理能力有高要求的业务，可以吸取缓冲区的经验。</p>

<ol>
<li>减少网络连接的交互</li>
<li>批量处理的方式</li>
<li>增加缓存</li>
</ol>

<h4 id="toc_10">资源冲突优化</h4>

<p><img src="media/16324912353122/16324935293757.jpg" alt="" style="width:399px;"/></p>

<p>按照锁<strong>级别</strong>：可分为乐观锁与悲观锁</p>

<p>按照锁<strong>类型</strong>：可分为公平锁与非公平锁</p>

<h4 id="toc_11">算法优化</h4>

<p>由于储存越来越便宜。往往采用空间换时间的方式</p>

<h4 id="toc_12">高效实现</h4>

<p><img src="media/16324912353122/16324937346857.jpg" alt="" style="width:754px;"/></p>

<h4 id="toc_13">JVM优化</h4>

<p>CMS垃圾回收器已经在Java14中被移除</p>

<h3 id="toc_14">常见系统瓶颈</h3>

<p>**CPU **</p>

<ul>
<li>通过top命令，观测CPU性能</li>
<li>通过负载，评估CPU任务执行的排队情况</li>
<li>通过vmstat，看CPU的繁忙程度</li>
</ul>

<p><strong>内存</strong></p>

<p><img src="media/16324912353122/16324944933260.jpg" alt="" style="width:721px;"/></p>

<p><img src="media/16324912353122/16324945583443.jpg" alt="" style="width:556px;"/></p>

<p><strong>I/O</strong></p>

<ul>
<li>iostat命令</li>
</ul>

<h4 id="toc_15">top命令</h4>

<p><img src="media/16324912353122/16324941952343.jpg" alt="" style="width:677px;"/></p>

<p><img src="media/16324912353122/16324941859111.jpg" alt="" style="width:585px;"/></p>

<p><img src="media/16324912353122/16324945400140.jpg" alt="" style="width:572px;"/></p>

<h4 id="toc_16">负载</h4>

<p>uptime命令</p>

<p><img src="media/16324912353122/16324943381092.jpg" alt="" style="width:372px;"/></p>

<h4 id="toc_17">vmstat命令</h4>

<p><img src="media/16324912353122/16324943999070.jpg" alt="" style="width:591px;"/></p>

<p><img src="media/16324912353122/16324944282460.jpg" alt="" style="width:483px;"/></p>

]]></content>
  </entry>
  
</feed>
