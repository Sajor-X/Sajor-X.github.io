<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2022-05-18T23:12:33+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[某音APP广告爬取]]></title>
    <link href="http://565785929.github.io/16520626552663.html"/>
    <updated>2022-05-09T10:17:35+08:00</updated>
    <id>http://565785929.github.io/16520626552663.html</id>
    <content type="html"><![CDATA[
<p>接到个工作，就是写个爬虫把广告视频数据爬下来，供公司同事模仿。</p>

<p>某音有app手机端和web网页端。web端比较好分析，但是刷了半天都没有看到广告影子，不知道是没有标识，还是说就没有广告投放。所以只能搞客户端了。</p>

<h2 id="toc_0">初次尝试</h2>

<p>开始下载了5.0版的安卓模拟器，下载了比较旧的某音APP 17.3版本，发现是可以抓到包的，但是无法登陆，提示版本过低。所以只能升级APP版本，升级到最新版发现之前的抓包工具无法抓到包了，提示 SSL Handshake Failed。</p>

<h2 id="toc_1">SSL Pinning</h2>

<p>在 android 7.0+以上的版本，就会有 SSL Pinning， 只信任系统内置的证书。&quot;客户端在收到服务器的证书后，对该证书进行强校验，验证该证书是不是客户端承认的证书，如果不是，则直接断开连接。&quot;</p>

<h3 id="toc_2">一：xposed 及其插件 <a href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe</a> (可以配合 virtualxposed)</h3>

<p>JustTrustMe 是一个用来禁用、绕过 SSL 证书检查的基于 Xposed 模块。JustTrustMe 是将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查。</p>

<h3 id="toc_3">二：将证书安装到系统证书中（需要 root ）</h3>

<p>系统证书的目录是：/system/etc/security/cacerts/<br/>
每个证书的命名规则为：<Certificate_Hash>.<Number><br/>
Certificate_Hash 表示证书文件的 hash 值，Number 是为了防止证书文件的 hash 值一致而增加的后缀;<br/>
证书的 hash 值可以由命令计算出来，在终端输入 openssl x509 -subject_hash_old -in <Certificate_File>，其中 Certificate_File 为证书路径，将证书重命名为 hash.0 放入系统证书目录，之后你就可以正常抓包了。</p>

<h2 id="toc_4">某音证书锁定</h2>

<p>在尝试了以上方案之后，发现还是无法绕过某音的证书锁定，可能不是用系统证书做校验，而是自己的证书。于是开始调研新的方案。</p>

<h2 id="toc_5">调研方案</h2>

<ul>
<li>一：修改libsscronet.so文件</li>
<li>二：使用Android Hook框架如 Frida</li>
<li>三：使用测试框架开源Appium或网易Airtest</li>
</ul>

<h3 id="toc_6">方案一：</h3>

<p>通过修改某音编译好的so库代码，修改判断证书部分函数返回值，达到绕过ssl pinning的目的，然后使用抓包工具抓包。<br/>
优点：不用配置hook框架，修改一次即可覆盖<br/>
缺点：没有核心技术能力，无法主动更新迭代</p>

<ul>
<li><a href="https://bbs.pediy.com/thread-269028.htm">看雪论坛原创17.3</a></li>
<li><a href="https://www.52pojie.cn/thread-1611180-1-1.html">吾爱破解20.0</a></li>
<li><a href="https://www.cnblogs.com/theseventhson/p/15161954.html">网友分析</a></li>
</ul>

<h3 id="toc_7">方案二：</h3>

<p>类似方案一，通过hook框架，动态修改安卓内部代码函数的入参，返回值等信息，达到绕过ssl pinning的目的，然后使用抓包工具。</p>

<p>优点：框架热门资料多，较方案三可拓展性强<br/>
缺点：</p>

<ul>
<li><a href="https://www.jianshu.com/p/56b57ceefcae">简书抖音Frida代码</a></li>
<li><a href="https://bbs.pediy.com/thread-268014.htm">看雪论坛某书hook过程</a></li>
<li><a href="https://blog.51cto.com/u_15101562/2622472?b=totalstatistic">51CTO抖音数据采集Frida教程，Frida Java Hook 详解：代码及示例</a></li>
<li><a href="https://www.its404.com/searchArticle?qc=frida%20hook%20%E6%8A%93%E5%8C%85&amp;page=1">frida教程</a></li>
<li><a href="https://www.codetd.com/article/12727405">抖音数据采集Frida脱壳工具</a></li>
<li><a href="http://zhaoxincheng.com/index.php/2021/07/30/%e7%9f%ad%e8%a7%86%e9%a2%91%e6%9c%80%e6%96%b0%e7%89%88%e9%80%9a%e7%94%a8quic%e5%8d%8f%e8%ae%ae%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88/">快手、抖音短视频最新版抓包</a></li>
</ul>

<h3 id="toc_8">方案三：</h3>

<p>通过安卓测试框架截图，拿到相关数据<br/>
优点：简单，且多平台适用<br/>
缺点：拿不到准确数，不好拓展</p>

<ul>
<li><a href="https://airtest.readthedocs.io/zh_CN/latest/">airtest文档</a></li>
<li><a href="https://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver">防止selenium被检测</a></li>
<li><a href="https://blog.csdn.net/sirobot/article/details/105730906">关于selenium的一些资料</a></li>
</ul>

<h2 id="toc_9">再次尝试</h2>

<h3 id="toc_10">方案一：</h3>

<p>首先采用修改so的方式，由于本人没有吾爱的会员，所以只能下载到看雪上17.3版本的so文件。但是之前装好的安卓5.0搭配 某音17.5 是不需要破解，直接就可以抓包。所以尝试使用新版替换一下，结果发现抖音打不开了。。</p>

<p>由于不懂逆向，看不懂汇编，所以只能安装17.3版本抖音，下载原libsscronet.so文件与论坛大佬提供的做对比。</p>

<pre class="line-numbers"><code class="language-text"># 使用vim对比
vimdiff -bd org_libsscronet.so gai_libsscronet.so

# 切换窗口
ctrl+w 

# 二进制转十六进制查看
:%! xxd

# 下一处不同
[c
# 上一处不同
]c
</code></pre>

<p>可是只发现了两处不同，和论坛大佬提到的四处对应不上。但是也没有头绪，只能留下没有技术的眼泪。</p>

<p><img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-164224.png" alt="飞书20220512-164224"/></p>

<p>之后使用<code>IDA PRO</code>工具打开两个so文件，根据<code>vim</code> 提示的地址 <code>001ccbb0</code> 在<code>IDA PRO</code>中按快捷键 <code>g</code> 跳转。</p>

<p><img src="media/16520626552663/16523453793823.jpg" alt=""/></p>

<p>然后对比两个文件的不同。</p>

<p><img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-171018.png" alt="飞书20220512-171018"/><br/>
<img src="media/16520626552663/%E9%A3%9E%E4%B9%A620220512-171016.png" alt="飞书20220512-171016"/></p>

<p>发现在 <code>MOVS  R0, #1</code> 这里有不同。然后记录一下周边函数名称<code>HandleVerifyResult &amp; VerifyCert</code></p>

<p>于是下载某音APP20.5最新版，如法炮制。将1改为0，然后 apply patchs并将该文件放入原来位置，修改一下用户组和权限，重启虚拟机即可。</p>

<h2 id="toc_11">protobuf</h2>

<p>抓到包之后发现里面文字显示都不正常，通过请求头发现，原来使用的谷歌的protobuf协议，类似json和xml用于两端数据传输，因为protobuf更节省空间，传输过程中将变量名省略，变量名都以文件的方式存储在服务器和客户端上，所以我们需要使用Python的<br/>
blackboxprotobuf库来解析。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 开启wsl并开启远程]]></title>
    <link href="http://565785929.github.io/16488664948376.html"/>
    <updated>2022-04-02T10:28:14+08:00</updated>
    <id>http://565785929.github.io/16488664948376.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16488664948376/16528851318715.jpg" alt=""/></p>

<p>首先在linux中启动SSH连接支持</p>

<pre class="line-numbers"><code class="language-text">#客户端
sudo apt-get install openssh-client
#服务器
sudo apt-get install openssh-server
#或
apt-get install ssh
</code></pre>

<p>编辑配置文件</p>

<pre class="line-numbers"><code class="language-text">sudo vi /etc/ssh/sshd_config
</code></pre>

<p>增加以下配置</p>

<pre class="line-numbers"><code class="language-text">Port 2222             # wsl端口
PermitRootLogin yes   # 可以root远程登录
AllowUsers xxx        # 开启wsl时新建的账户
</code></pre>

<p><strong>重启</strong></p>

<p><code>sudo service ssh --full-restart</code></p>

<p>在使用ssh连接时若报错 Disconnected:No supported authentication methods available</p>

<p>是因为 /etc/ssh/sshd_config 中包含 这条配置</p>

<p><code>PasswordAuthentication no</code></p>

<p>我们需要将它注释掉，或改为yes然后重启 ssh服务</p>

<h2 id="toc_0">端口映射</h2>

<p>这个时候自己电脑上的xhell是可以连接的了, 但是想要在其他的计算机上访问, 就需要在windows系统作端口映射了。</p>

<pre class="line-numbers"><code class="language-text"># netsh interface portproxy add v4tov4 listenport=[win10端口] listenaddress=0.0.0.0 connectport=[虚拟机的端口] connectaddress=[虚拟机的ip]
netsh interface portproxy add v4tov4 listenport=22 listenaddress=0.0.0.0 connectport=22 connectaddress=172.22.22.22
 
#检测是否设置成功
netsh interface portproxy show all
 
#删除端口映射
netsh interface portproxy delete v4tov4 listenaddress=监听地址 listenport=监听端口
</code></pre>

<p>此时，即可在其他电脑上用windows的IP和配置的端口进行ssh连接了。若不可以，可以尝试打开windows防火墙，新建一条入站规则 tcp端口为 2223。</p>

<h2 id="toc_1">桌面</h2>

<p>后续可以在wsl中安装桌面程序 例如 <a href="https://baiyue.one/archives/1658.html">KDE</a></p>

<p>参考：<a href="https://blog.csdn.net/weixin_43718675/article/details/106844150">开启WSL(win10的linux子系统)并实现远程连接</a>、<a href="https://blog.csdn.net/lcuwb/article/details/82885920">设置WSL可远程连接</a>、<a href="https://blog.csdn.net/u010328478/article/details/116457769">WSL允许用其他电脑ssh连接</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java8 特性 Optional]]></title>
    <link href="http://565785929.github.io/16487053528391.html"/>
    <updated>2022-03-31T13:42:32+08:00</updated>
    <id>http://565785929.github.io/16487053528391.html</id>
    <content type="html"><![CDATA[
<p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>

<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>

<h2 id="toc_0">创建 Option</h2>

<p>Optional 有两个函数(of &amp; ofNullable)可以传参初始化。一个empty函数没有参数。</p>

<p><img src="media/16487053528391/16487116675343.jpg" alt="" style="width:611px;"/></p>

<h3 id="toc_1">empty</h3>

<p><code>empty</code> 函数就是，直接返回 <code>new Optional()</code> 并且 <code>value</code> 为空 <code>null</code>。</p>

<p><img src="media/16487053528391/16487128365738.jpg" alt="" style="width:1321px;"/></p>

<h3 id="toc_2">of &amp; ofNullable</h3>

<p><strong>of</strong></p>

<p>首先看 <code>of</code> 我们发现这个函数就是将 <code>Optional</code> 中 <code>value</code> 的值赋值为参数传入的 <code>value</code> 值，假如传入的值为空 <code>null</code> 则抛出异常。源码如下：</p>

<p><img src="media/16487053528391/16487121432837.jpg" alt=""/></p>

<p><strong>ofNullable</strong></p>

<p>而 <code>ofNullable</code> 就是将前两个函数 <code>empty</code> 和 <code>of</code> 结合起来，首先判断传入的值 <code>value</code> 是否为空 <code>null</code>， 为空就调用 <code>empty</code> 函数， 不为空就调用 <code>of</code> 函数。</p>

<p><img src="media/16487053528391/16487123039061.jpg" alt=""/></p>

<p>所以一般我们使用 ofNullable 函数来初始化 Optional 对象，方便之后调用它的方法。</p>

<h2 id="toc_3">应用</h2>

<pre class="line-numbers"><code class="language-java">    /**
     * 用于测试的 User 类
     */
    @Data
    @AllArgsConstructor
    public static class User {
        String name;
        int id;
    }
</code></pre>

<p>获取对象下某属性的值，原来需要判断一下 <code>user</code> 是否为空，不为空再获取 <code>name</code> 属性，现在可以通过 <code>orElse</code> 一行实现。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    User user1 = null;
    String u1 = Optional.ofNullable(user1).map(User::getName).orElse(&quot;default&quot;);
    User user2 = new User(null, 12);
    String u2 = Optional.ofNullable(user2).map(User::getName).orElse(&quot;default&quot;);
    User user3 = new User(&quot;Sajor&quot;, 12);
    String u3 = Optional.ofNullable(user3).map(User::getName).orElse(&quot;default&quot;);

    System.out.println(u1);  // default
    System.out.println(u2);  // default
    System.out.println(u3);  // SAJOR
}
</code></pre>

<p>再进一步也可以通过 <code>map</code> 来持续对对象下属性进行更复杂的操作。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    // 通过变大写函数
    String u1 = Optional.ofNullable(user1).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    User user2 = new User(null, 12);
    String u2 = Optional.ofNullable(user2).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    User user3 = new User(&quot;Sajor&quot;, 12);
    String u3 = Optional.ofNullable(user3).map(User::getName).map(String::toUpperCase).orElse(&quot;default&quot;);
    // 通过过滤
    User user4 = new User(&quot;Sajor&quot;, 12);
    String u4 = Optional.ofNullable(user4).map(User::getName).map(String::toUpperCase).filter(s -&gt; s.equals(&quot;SAJOR&quot;)).orElse(&quot;default&quot;);
    User user5 = new User(&quot;Sajor&quot;, 12);
    String u5 = Optional.ofNullable(user5).map(User::getName).map(String::toUpperCase).filter(s -&gt; s.equals(&quot;sajor&quot;)).orElse(&quot;default&quot;);

    System.out.println(u1);  // default
    System.out.println(u2);  // default
    System.out.println(u3);  // SAJOR
    System.out.println(u4);  // SAJOR
    System.out.println(u5);  // default
}
</code></pre>

<p>也可以通过 <code>ifPresent</code> 函数修改对象下的属性</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    // 修改属性
    User user1 = new User(null, 12);
    Optional.ofNullable(user1).ifPresent(user -&gt; {
        user.setId(13);
        user.setName(&quot;Sajor&quot;);
    });
    User user2 = null;
    Optional.ofNullable(user2).ifPresent(user -&gt; {
        user.setId(13);
        user.setName(&quot;Sajor&quot;);
    });

    System.out.println(user1);  // User(name=Sajor, id=13)
    System.out.println(user2);  // null
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Word Cloud 词云重叠算法]]></title>
    <link href="http://565785929.github.io/16486272439635.html"/>
    <updated>2022-03-30T16:00:43+08:00</updated>
    <id>http://565785929.github.io/16486272439635.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16486272439635/16528852569694.jpg" alt=""/></p>

<p><a href="https://github.com/amueller/word_cloud">word_cloud</a> </p>

<h2 id="toc_0">积分图算法</h2>

<p><img src="media/16486272439635/16486272595252.jpg" alt="" style="width:726px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python pip源 国内源]]></title>
    <link href="http://565785929.github.io/16486184863200.html"/>
    <updated>2022-03-30T13:34:46+08:00</updated>
    <id>http://565785929.github.io/16486184863200.html</id>
    <content type="html"><![CDATA[
<p>pip 安装第三方库速度太慢</p>

<p>可设置 pip 从国内的镜像源下载安装</p>

<pre class="line-numbers"><code class="language-text">阿里云 http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣 http://pypi.douban.com/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/
</code></pre>

<p>设置方法，以清华镜像源为例：</p>

<p>临时使用</p>

<pre class="line-numbers"><code class="language-text">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxxxxxx
</code></pre>

<p>永久设置</p>

<pre class="line-numbers"><code class="language-text">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ngrok 内网穿透]]></title>
    <link href="http://565785929.github.io/16485397489109.html"/>
    <updated>2022-03-29T15:42:28+08:00</updated>
    <id>http://565785929.github.io/16485397489109.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16485397489109/16485401540848.jpg" alt=""/></p>

<p><a href="https://dashboard.ngrok.com/get-started/setup">ngrok</a> 安装和使用太简单了，可以方便今后调试带回调的三方接口。</p>

<p>按照文档保存密钥后，输入 <code>ngrok http 8080</code> 启动</p>

<p><img src="media/16485397489109/16485400843573.jpg" alt="" style="width:781px;"/></p>

<p>图中 Web Interface 的 4040 地址，还可以看到ngrok作为中间人劫持记录到的所有接口文件数据。</p>

<p><img src="media/16485397489109/16485403495497.jpg" alt="" style="width:1400px;"/></p>

<h2 id="toc_0">配置文件</h2>

<p>输入token之后，会自动生成配置文件，我们可以在配置文件里配置我们常用的端口，例如8080。</p>

<pre class="line-numbers"><code class="language-text">tunnels:
  dev:
    proto: http
    addr: 8080
  aria:
    proto: tcp
    addr: 6800
</code></pre>

<p>这样可以直接使用命令 <code>ngrok start dev</code> 只启动名为 dev 的 8080 端口映射。 </p>

<p>也可以使用 <code>ngrok start --all</code> 启动所有映射。</p>

<p>配置属性可参考<a href="https://ngrok.com/docs">文档</a>：</p>

<p><img src="media/16485397489109/16485505636452.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis Codis 第三方集群实现]]></title>
    <link href="http://565785929.github.io/16480451786591.html"/>
    <updated>2022-03-23T22:19:38+08:00</updated>
    <id>http://565785929.github.io/16480451786591.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/CodisLabs/codis">Codis</a> 是 Redis 集群方案之一，令我们感到骄傲的是，它是中国人开发并开源的，来自前豌豆荚中间件团队。</p>

<p>有了 Codis 技术积累之后，项目「突头人」刘奇又开发出来中国人自己的开源分布式数据库 —— <a href="https://github.com/pingcap/tidb">TiDB</a></p>

<p><img src="media/16480451786591/16480452986071.jpg" alt="" style="width:626px;"/></p>

<p>Codis 使用 Go 语言开发，它是一个代理中间件，它和 Redis 一样也使用 Redis 协议对外提供服务，当客户端向 Codis 发送指令时，Codis 负责将指令转发到后面的 Redis 实例来执行，并将返回结果再转回给客户端。</p>

<p><img src="media/16480451786591/16480453431608.jpg" alt="" style="width:492px;"/></p>

<p>Codis 上挂接的所有 Redis 实例构成一个 Redis 集群，当集群空间不足时，可以通过动态增加 Redis 实例来实现扩容需求。</p>

<p>客户端操纵 Codis 同操纵 Redis 几乎没有区别，还是可以使用相同的客户端 SDK，不需要任何变化。</p>

<p>因为 Codis 是无状态的，它只是一个转发代理中间件，这意味着我们可以启动多个 Codis 实例，供客户端使用，每个 Codis 节点都是对等的。因为单个 Codis 代理能支撑的 QPS 比较有限，通过启动多个 Codis 代理可以显著增加整体的 QPS 需求，还能起到容灾功能，挂掉一个 Codis 代理没关系，还有很多 Codis 代理可以继续服务。</p>

<p><img src="media/16480451786591/16480453830021.jpg" alt="" style="width:443px;"/></p>

<h2 id="toc_0">Codis 分片原理</h2>

<p>Codis 要负责将特定的 key 转发到特定的 Redis 实例。Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p>

<p><img src="media/16480451786591/16480836489628.jpg" alt=""/></p>

<p>每个槽位都会唯一映射到后面的多个 Redis 实例之一，Codis 会在内存维护槽位和 Redis 实例的映射关系。这样有了上面 key 对应的槽位，那么它应该转发到哪个 Redis 实例就很明确了。</p>

<pre class="line-numbers"><code class="language-python">hash = crc32(command.key)
slot_index = hash % 1024
redis = slots[slot_index].redis
redis.do(command)
</code></pre>

<p>槽位数量默认是1024，它是可以配置的，如果集群节点比较多，建议将这个数值配置大一些，比如2048、4096。</p>

<h2 id="toc_1">不同的 Codis 实例之间槽位关系如何同步？</h2>

<p>如果 Codis 的槽位映射关系只存储在内存里，那么不同的 Codis 实例之间的槽位关系就无法得到同步。所以 Codis 还需要一个分布式配置存储数据库专门用来持久化槽位关系。Codis 开始使用 ZooKeeper，后来连 etcd 也一块支持了。</p>

<p><img src="media/16480451786591/16480837412388.jpg" alt=""/></p>

<p>Codis 将槽位关系存储在 zk 中，并且提供了一个 Dashboard 可以用来观察和修改槽位关系，当槽位关系变化时，Codis Proxy 会监听到变化并重新同步槽位关系，从而实现多个 Codis Proxy 之间共享相同的槽位关系配置。</p>

<h2 id="toc_2">扩容</h2>

<p>刚开始 Codis 后端只有一个 Redis 实例，1024 个槽位全部指向同一个 Redis。然后一个 Redis 实例内存不够了，所以又加了一个 Redis 实例。这时候需要对槽位关系进行调整，将一半的槽位划分到新的节点。这意味着需要对这一半的槽位对应的所有 key 进行迁移，迁移到新的 Redis 实例。</p>

<p><strong>那 Codis 如何找到槽位对应的所有 key 呢？</strong></p>

<p>Codis 对 Redis 进行了改造，增加了 SLOTSSCAN 指令，可以遍历指定 slot 下所有的 key。Codis 通过 SLOTSSCAN 扫描出待迁移槽位的所有的 key，然后挨个迁移每个 key 到新的 Redis 节点。</p>

<p>在迁移过程中，Codis 还是会接收到新的请求打在当前正在迁移的槽位上，因为当前槽位的数据同时存在于新旧两个槽位中，Codis 如何判断该将请求转发到后面的哪个具体实例呢？</p>

<p>Codis 无法判定迁移过程中的 key 究竟在哪个实例中，所以它采用了另一种完全不同的思路。当 Codis 接收到位于正在迁移槽位中的 key 后，会立即强制对当前的单个 key 进行迁移，迁移完成后，再将请求转发到新的 Redis 实例。</p>

<pre class="line-numbers"><code class="language-text">slot_index = crc32(command.key) % 1024
if slot_index in migrating_slots:
    do_migrate_key(command.key)  # 强制执行迁移
    redis = slots[slot_index].new_redis
else:
    redis = slots[slot_index].redis
redis.do(command)
</code></pre>

<h2 id="toc_3">自动均衡</h2>

<p>Redis 新增实例，手工均衡slots太繁琐，所以 Codis 提供了自动均衡功能。自动均衡会在系统比较空闲的时候观察每个 Redis 实例对应的 Slots 数量，如果不平衡，就会自动进行迁移。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 集群 Sentinel 哨兵模式]]></title>
    <link href="http://565785929.github.io/16476622390377.html"/>
    <updated>2022-03-19T11:57:19+08:00</updated>
    <id>http://565785929.github.io/16476622390377.html</id>
    <content type="html"><![CDATA[
<p>我们必须有一个高可用方案来抵抗节点故障，当故障发生时可以自动进行从主切换，程序可以不用重启，Redis 官方提供了这样一种方案 —— Redis Sentinel(哨兵)。</p>

<p><img src="media/16476622390377/16477425526206.jpg" alt="" style="width:463px;"/></p>

<p>我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。</p>

<p>它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉后，集群将可能自动调整为下图所示结构。</p>

<p><img src="media/16476622390377/16477782314095.jpg" alt="" style="width:520px;"/></p>

<p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经挂掉了主节点，待它恢复后，集群会调整为下面这张图。</p>

<p><img src="media/16476622390377/16477782868816.jpg" alt="" style="width:428px;"/></p>

<p>此时原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系。</p>

<h2 id="toc_0">消息丢失</h2>

<p>Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。Sentinel 无法保证消息完全不丢失，但是也尽可能保证消息少丢失。它有两个选项可以限制主从延迟过大。</p>

<pre class="line-numbers"><code class="language-text">min-slaves-to-write 1
min-slaves-max-lag 10
</code></pre>

<p>第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。</p>

<p>何为正常复制，何为异常复制？这个就是由第二个参数控制的，它的单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</p>

<h2 id="toc_1">Sentinel 基本使用</h2>

<p>接下来我们看看客户端如何使用 sentinel，标准的流程应该是客户端可以通过 sentinel 发现主从节点的地址，然后在通过这些地址建立相应的连接来进行数据存取操作。我们来看看 Python 客户端是如何做的。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; from redis.sentinel import Sentinel
&gt;&gt;&gt; sentinel = Sentinel([(&#39;localhost&#39;, 26379)], socket_timeout=0.1)
&gt;&gt;&gt; sentinel.discover_master(&#39;mymaster&#39;)
(&#39;127.0.0.1&#39;, 6379)
&gt;&gt;&gt; sentinel.discover_slaves(&#39;mymaster&#39;)
[(&#39;127.0.0.1&#39;, 6380)]
</code></pre>

<p>sentinel 的默认端口是 26379，不同于 Redis 的默认端口 6379，通过 sentinel 对象的 discover_xxx 方法可以发现主从地址，主地址只有一个，从地址可以有多个。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; master = sentinel.master_for(&#39;mymaster&#39;, socket_timeout=0.1)
&gt;&gt;&gt; slave = sentinel.slave_for(&#39;mymaster&#39;, socket_timeout=0.1)
&gt;&gt;&gt; master.set(&#39;foo&#39;, &#39;bar&#39;)
&gt;&gt;&gt; slave.get(&#39;foo&#39;)
&#39;bar&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 集群-主从同步]]></title>
    <link href="http://565785929.github.io/16475965636227.html"/>
    <updated>2022-03-18T17:42:43+08:00</updated>
    <id>http://565785929.github.io/16475965636227.html</id>
    <content type="html"><![CDATA[
<p>主从复制是 Redis 分布式的基础，Redis 的高可用离开了主从复制将无从进行。</p>

<p>不过复制功能也不是必须的，如果你将 Redis 只用来做缓存，跟 memcache 一样来对待，也就无需要从库做备份，挂掉了重新启动一下就行。但是只要你使用了 Redis 的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>

<h2 id="toc_0">CAP 原理</h2>

<p>现代分布式系统的理论基石——CAP 原理，CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</p>

<ul>
<li><strong>C</strong> - Consistent ，一致性</li>
<li><strong>A</strong> - Availability ，可用性</li>
<li><strong>P</strong> - Partition tolerance ，分区容忍性</li>
</ul>

<p><img src="media/16475965636227/16475969218160.jpg" alt="" style="width:704px;"/></p>

<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「<strong>网络分区</strong>」。</p>

<p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「<strong>一致性</strong>」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「<strong>可用性</strong>」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p>

<p><img src="media/16475965636227/16475970141647.jpg" alt="" style="width:415px;"/></p>

<p>一句话概括 CAP 原理就是——<strong>网络分区发生时，一致性和可用性两难全</strong>。</p>

<h2 id="toc_1">最终一致</h2>

<p>Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「<strong>一致性</strong>」要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「<strong>可用性</strong>」。</p>

<p>Redis 保证「<strong>最终一致性</strong>」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。</p>

<p><img src="media/16475965636227/16476122373622.jpg" alt="" style="width:688px;"/></p>

<h2 id="toc_2">主从同步</h2>

<p>Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。</p>

<p><img src="media/16475965636227/16476121091943.jpg" alt="" style="width:520px;"/></p>

<h2 id="toc_3">增量同步</h2>

<p>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了 (偏移量)。</p>

<p>因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer 中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。</p>

<p><img src="media/16475965636227/16475988392974.jpg" alt="" style="width:183px;"/></p>

<p>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 —— 快照同步。</p>

<h2 id="toc_4">快照同步</h2>

<p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。</p>

<p>在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。</p>

<p><img src="media/16475965636227/16475988707034.jpg" alt="" style="width:435px;"/></p>

<p>所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</p>

<h2 id="toc_5">增加从节点</h2>

<p>当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增量同步。</p>

<h2 id="toc_6">无盘复制</h2>

<p>主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。</p>

<p>所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。</p>

<h2 id="toc_7">Wait 指令</h2>

<p>Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。</p>

<pre class="line-numbers"><code class="language-text">&gt; set key value
OK
&gt; wait 1 0
(integer) 1
</code></pre>

<p>wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到 N 个从库同步完成达成一致。</p>

<p>假设此时出现了网络分区，wait 指令第二个参数时间 t=0，主从同步无法继续进行，wait 指令会永远阻塞，Redis 服务器将丧失可用性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 基数树]]></title>
    <link href="http://565785929.github.io/16474851306463.html"/>
    <updated>2022-03-17T10:45:30+08:00</updated>
    <id>http://565785929.github.io/16474851306463.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 紧凑列表]]></title>
    <link href="http://565785929.github.io/16474851167642.html"/>
    <updated>2022-03-17T10:45:16+08:00</updated>
    <id>http://565785929.github.io/16474851167642.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 跳跃列表]]></title>
    <link href="http://565785929.github.io/16474851118548.html"/>
    <updated>2022-03-17T10:45:11+08:00</updated>
    <id>http://565785929.github.io/16474851118548.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 快速列表]]></title>
    <link href="http://565785929.github.io/16474850990931.html"/>
    <updated>2022-03-17T10:44:59+08:00</updated>
    <id>http://565785929.github.io/16474850990931.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 压缩列表]]></title>
    <link href="http://565785929.github.io/16474850885819.html"/>
    <updated>2022-03-17T10:44:48+08:00</updated>
    <id>http://565785929.github.io/16474850885819.html</id>
    <content type="html"><![CDATA[
<p>Redis 为了节约内存空间，zset、hash容器对象在元素较少的时候，采用压缩列表（ziplist）进行存储。</p>

<p>压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。</p>

<pre class="line-numbers"><code class="language-text">&gt; zadd pro 1 go 2 py 3 java
(integer) 3
&gt; debug object pro
Value at:0x7f9c8df044c0 refcount:1 encoding:ziplist serializedlength:32 lru:4867870 lru_seconds_idle:6
&gt; hmset bok go fast py slow java fast
OK
&gt; debug object bok
Value at:0x7f9c8df1adf0 refcount:1 encoding:ziplist serializedlength:44 lru:4867905 lru_seconds_idle:6
</code></pre>

<p>encoding:ziplist 表示内部采用压缩列表进行存储。</p>

<pre class="line-numbers"><code class="language-text">struct ziplist&lt;T&gt; {
    int32 zlbytes; // 整个压缩列表占用字节数
    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}
</code></pre>

<p><img src="media/16474850885819/16490362028362.jpg" alt=""/></p>

<p>压缩列表为了支持双向遍历，所以才会有ztail_offset这个字段，用来快速定位到最后一个元素，然后利用最后一个元素的长度，倒着遍历。</p>

<p>entry块随着容纳的元素类型不同。也会有不一样的结构。</p>

<pre class="line-numbers"><code class="language-text">struct entry {
    int&lt;var&gt; prevlen; // 前一个 entry 的字节长度
    int&lt;var&gt; encoding; // 元素类型编码
    optional byte[] content; // 元素内容
}
</code></pre>

<p><img src="media/16474850885819/16490369512939.jpg" alt="" style="width:731px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[倒排索引-字符串相似匹配（结巴分词、中文转拼音）]]></title>
    <link href="http://565785929.github.io/16469632028293.html"/>
    <updated>2022-03-11T09:46:42+08:00</updated>
    <id>http://565785929.github.io/16469632028293.html</id>
    <content type="html"><![CDATA[
<p>工作中，遇到有两个不同的系统，两个系统中有相同的功能，维护一个主播的名称。现在准备将两个系统的主播合并到一起。因为主播名称可能由不同的人维护的，他们也不知道主播的真实姓名，比如一条小团团，可能维护成了亿条小团团，等等。</p>

<p>为了解决主播重复问题，现在想了一个办法，将要导入的一方，做一个列表，将原有系统所有与其相似的主播名称展示出来。就像这样。</p>

<p><img src="media/16469632028293/16469634927751.jpg" alt="" style="width:540px;"/></p>

<p>通过与大佬们的讨论、启发。现准备使用以下方案。</p>

<ul>
<li>使用正则表达式，将昵称中的emoji剔除，只提取汉字和英文数字</li>
<li>使用中文分词法，将昵称字符串分成一个个的单词。并将词组个数为一的删去</li>
<li>两个系统的主播昵称进行同样的操作</li>
<li>之后遍历要导入的一方，与原有系统的拼音做对比，有重复的标记下来</li>
<li>最后导出文件，拿给运营同事人工比对</li>
</ul>

<h2 id="toc_0">部分示例代码：</h2>

<h3 id="toc_1">核心转换功能</h3>

<pre class="line-numbers"><code class="language-text">import re
import jieba
import pypinyin

def get_words(name):
    # 提取汉字和英文数字
    name = re.sub(&#39;[^\u4e00-\u9fa5a-zA-Z0-9]&#39;, &#39;&#39;, name)
    seg_list = jieba.cut_for_search(name)  # 搜索引擎模式
    word_list = []
    for j in seg_list:
        print(j, end=&#39;,&#39;)
        # 去除长度为一的词
        if len(j) != 1:
            # 将词转换成拼音，并连接成字符串
            word_list.append(&#39;&#39;.join(pypinyin.lazy_pinyin(j)))
    return word_list
    
get_words(&quot;一条小团团&quot;)

&gt; 一条,小,团团,
&gt; [&#39;yitiao&#39;, &#39;tuantuan&#39;]
</code></pre>

<h3 id="toc_2">原有系统制作哈希字典，方便查找</h3>

<pre class="line-numbers"><code class="language-text">bigMap = {}
jeecg_data = db.execute_sql(&#39;select * from xxx&#39;, DB)[1]

for jeecg in jeecg_data:
    words = get_words(jeecg.get(&#39;name&#39;))
    for word in words:
        if bigMap.get(word) is None:
            bigMap[word] = {
                &#39;name-id&#39; = []
            }
        bigMap[word][&#39;name-id&#39;].append(&quot;%s#%s&quot; % (jeecg.get(&#39;name&#39;), jeecg.get(&#39;id&#39;)))
</code></pre>

<h3 id="toc_3">需导入的主播</h3>

<pre class="line-numbers"><code class="language-text">result_list = []
jane_data = db.execute_sql(&quot;select * from xxx&quot;, DB)[1]

for jane in jane_data:
    words = get_words(jane.get(&#39;name&#39;))
    res = {
        &#39;id&#39;: jane.get(&#39;id&#39;),
        &#39;head&#39;: jane.get(&#39;head&#39;),
        &#39;name&#39;: jane.get(&#39;name&#39;),
        &#39;name-id&#39;: []
    }

    for word in words:
        if bigMap.get(word):
            res[&#39;name-id&#39;].extend(bigMap.get(word).get(&#39;name-id&#39;))
            # 去重（可能一个昵称存在多个单词相同）
            res[&#39;name-id&#39;] = list(set(res[&#39;name-id&#39;]))
    result_list.append(res)
</code></pre>

<h3 id="toc_4">导出文件</h3>

<pre class="line-numbers"><code class="language-text">for i in result_list:
    with open(&quot;foo.txt&quot;, &quot;a+&quot;) as f:
        for j in i.get(&#39;name-id&#39;):
            f.write(i.get(&#39;name&#39;))
            f.write(&#39;\t&#39;)
            f.write(i.get(&#39;id&#39;))
            f.write(&#39;\t&#39;)
            f.write(j)
            f.write(&#39;\t&#39;)
            f.write(&#39;\n&#39;)
</code></pre>

<p>用到的库：<a href="https://github.com/fxsjy/jieba">jieba</a>, <a href="https://github.com/mozillazg/python-pinyin">pypinyin</a></p>

<h2 id="toc_5">倒排索引</h2>

<p>之后才知道，原来我代码中构建的bigMap其实是一个倒排索引，马上补习了关于倒排索引的知识。</p>

<p>顾名思义，有倒排就有正排。正排索引-forward index；倒排索引-inverted index。正排索引都知道，就是MySQL的索引，按id给数据排索引。</p>

<p><img src="media/16469632028293/16469752101409.jpg" alt="" style="width:745px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 日志切分]]></title>
    <link href="http://565785929.github.io/16461235353064.html"/>
    <updated>2022-03-01T16:32:15+08:00</updated>
    <id>http://565785929.github.io/16461235353064.html</id>
    <content type="html"><![CDATA[
<p>公司运维写的日志切分脚本写的很好，改日学习</p>

<pre class="line-numbers"><code class="language-bash">#!/bin/bash
# This script run at 23:59
# The Nginx logs path

# Nginx_conf
# Ngxconf=$(ps aux|grep nginx.conf |grep -v grep |awk &#39;{print $NF}&#39;)
Logs_path=&quot;/data/logs/nginx&quot;
Loglist=${Logs_path}/nginx_logs_list
BACKDIR=&quot;$(date -d &quot;yesterday&quot; +&quot;%Y&quot;)/$(date -d &quot;yesterday&quot; +&quot;%m&quot;)/$(date -d &quot;yesterday&quot; +&quot;%d&quot;)&quot;

cd $Logs_path &amp;&amp; ls -al *.log |awk &#39;{print $9}&#39;|sed &#39;s/.log//g&#39; &gt; $Loglist

[ -d ${Logs_path}/${BACKDIR} ] || mkdir -p ${Logs_path}/${BACKDIR}

cat $Loglist | while read listname
do
    echo $listname\.log
    mv ${Logs_path}/$listname\.log ${Logs_path}/${BACKDIR}/$listname\_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log
    cd ${Logs_path}/${BACKDIR}/
    tar zcvf $listname\_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log.tar.gz $listname\_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log
done

kill -USR1 `cat /data/app/nginx/nginx.pid`
/usr/local/nginx/sbin/nginx -t
/usr/local/nginx/sbin/nginx -s reload
find ${Logs_path}/${BACKDIR}/ -mtime +5 -name &quot;*.log&quot; -exec rm -f {} \;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抓取儿童网课]]></title>
    <link href="http://565785929.github.io/16459510132643.html"/>
    <updated>2022-02-27T16:36:53+08:00</updated>
    <id>http://565785929.github.io/16459510132643.html</id>
    <content type="html"><![CDATA[
<p>sed -i &#39;&#39; &#39;s/https:\/\///g&#39;  ./src/project.270f2.js</p>

<p>return e<br/>
i.PLAYERTYPE.TEACHER</p>

<p><a href="https://blog.csdn.net/u800820/article/details/100084999">火狐跨域配置</a></p>

<p>?prepare=1&amp;user_role=2&amp;user_type=1</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos8 yum安装错误]]></title>
    <link href="http://565785929.github.io/16458023133729.html"/>
    <updated>2022-02-25T23:18:33+08:00</updated>
    <id>http://565785929.github.io/16458023133729.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</p>
</blockquote>

<p>我的是这种错误</p>

<blockquote>
<p>Invalid configuration value: failovermethod=priority in /etc/yum.repos.d/CentOS-epel.repo; 配置：ID 为 &quot;failovermethod&quot; 的 OptionBinding 不存在<br/>
Repository epel is listed more than once in the configuration<br/>
CentOS Linux 8 - AppStream                                                                                         124  B/s |  38  B     00:00<br/><br/>
错误：为仓库 &#39;appstream&#39; 下载元数据失败 : Cannot prepare internal mirrorlist: No URLs in mirrorlist</p>
</blockquote>

<p>看这篇<a href="https://forketyfork.medium.com/centos-8-no-urls-in-mirrorlist-error-3f87c3466faa">博文</a>解决了，中国博客园的<a href="https://www.cnblogs.com/bpzblog/p/13918199.html">垃圾博客</a>不要再看了。调半天调不好。</p>

<p>执行如下命令即可解决</p>

<pre class="line-numbers"><code class="language-text">sudo cp -rf /etc/yum.repos.d /etc/yum.repos.bak
sudo sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; /etc/yum.repos.d/CentOS-*
sudo sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-*
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web日志分析工具 GoAccess]]></title>
    <link href="http://565785929.github.io/16458004850875.html"/>
    <updated>2022-02-25T22:48:05+08:00</updated>
    <id>http://565785929.github.io/16458004850875.html</id>
    <content type="html"><![CDATA[
<p>GoAccess：<a href="https://goaccess.io/">官方站</a>、<a href="https://www.goaccess.cc/">中国站</a>、<a href="https://github.com/allinurl/goaccess">GitHub</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins 权限控制]]></title>
    <link href="http://565785929.github.io/16457968431626.html"/>
    <updated>2022-02-25T21:47:23+08:00</updated>
    <id>http://565785929.github.io/16457968431626.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基于项目控制</h2>

<p>安装插件 Matrix Authorization Strategy</p>

<p>安全配置</p>

<p><img src="media/16457968431626/16457994058396.jpg" alt=""/></p>

<p>到项目配置里开启</p>

<p><img src="media/16457968431626/16457994303189.jpg" alt=""/></p>

<p>参考<a href="https://www.cnblogs.com/grey-wolf/p/8951796.html">Jenkins权限管理之Matrix Authorization Strategy</a></p>

<h2 id="toc_1">基于角色控制</h2>

<p>创建新用户<br/>
<img src="media/16457968431626/16457969441690.jpg" alt=""/></p>

<p>插件管理</p>

<p><img src="media/16457968431626/16457969588454.jpg" alt=""/></p>

<p>安装插件 Role-based Authorization Strategy </p>

<p><img src="media/16457968431626/16457969840784.jpg" alt=""/></p>

<p>全局安全配置 Manage Jenkins -&gt; Configure Global Security -&gt; Under Authorization, select Role Based Strategy. Click on Save.</p>

<p><img src="media/16457968431626/16457970735629.jpg" alt=""/></p>

<p>角色分配管理</p>

<p><img src="media/16457968431626/16457971422579.jpg" alt=""/></p>

<p>参考：<a href="https://www.guru99.com/create-users-manage-permissions.html">How to Create/Add Users in Jenkins &amp; Manage Permissions</a></p>

]]></content>
  </entry>
  
</feed>
